{"remainingRequest":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js??ref--4-1!D:\\work\\eui\\src\\components\\selectable\\matching_options.ts","dependencies":[{"path":"D:\\work\\eui\\src\\components\\selectable\\matching_options.ts","mtime":1649070093757},{"path":"D:\\work\\eui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1636976621750},{"path":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js","mtime":1649070120649}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2giOwoKLyoKICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yCiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoCiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0CiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIKICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlICJMaWNlbnNlIik7IHlvdSBtYXkKICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4KICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0CiAqCiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMAogKgogKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsCiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuCiAqICJBUyBJUyIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWQogKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUKICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucwogKiB1bmRlciB0aGUgTGljZW5zZS4KICovCnZhciBnZXRTZWFyY2hhYmxlTGFiZWwgPSBmdW5jdGlvbiBnZXRTZWFyY2hhYmxlTGFiZWwob3B0aW9uKSB7CiAgdmFyIG5vcm1hbGl6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTsKICB2YXIgc2VhcmNoYWJsZUxhYmVsID0gb3B0aW9uLnNlYXJjaGFibGVMYWJlbCB8fCBvcHRpb24ubGFiZWw7CiAgcmV0dXJuIG5vcm1hbGl6ZSA/IHNlYXJjaGFibGVMYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKSA6IHNlYXJjaGFibGVMYWJlbDsKfTsKCnZhciBnZXRTZWxlY3RlZE9wdGlvbkZvclNlYXJjaFZhbHVlID0gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25Gb3JTZWFyY2hWYWx1ZShzZWFyY2hWYWx1ZSwgc2VsZWN0ZWRPcHRpb25zKSB7CiAgdmFyIG5vcm1hbGl6ZWRTZWFyY2hWYWx1ZSA9IHNlYXJjaFZhbHVlLnRvTG93ZXJDYXNlKCk7CiAgcmV0dXJuIHNlbGVjdGVkT3B0aW9ucy5maW5kKGZ1bmN0aW9uIChvcHRpb24pIHsKICAgIHJldHVybiBnZXRTZWFyY2hhYmxlTGFiZWwob3B0aW9uKSA9PT0gbm9ybWFsaXplZFNlYXJjaFZhbHVlOwogIH0pOwp9OwoKdmFyIGNvbGxlY3RNYXRjaGluZ09wdGlvbiA9IGZ1bmN0aW9uIGNvbGxlY3RNYXRjaGluZ09wdGlvbihhY2N1bXVsYXRvciwgb3B0aW9uLCBub3JtYWxpemVkU2VhcmNoVmFsdWUsIGlzUHJlRmlsdGVyZWQsIHNlbGVjdGVkT3B0aW9ucykgewogIC8vIERvbid0IHNob3cgb3B0aW9ucyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCBpZgogIC8vIHRoZSBzZWxlY3RlZE9wdGlvbnMgbGlzdCBleGlzdHMKICBpZiAoc2VsZWN0ZWRPcHRpb25zKSB7CiAgICB2YXIgc2VsZWN0ZWRPcHRpb24gPSBnZXRTZWxlY3RlZE9wdGlvbkZvclNlYXJjaFZhbHVlKGdldFNlYXJjaGFibGVMYWJlbChvcHRpb24sIGZhbHNlKSwgc2VsZWN0ZWRPcHRpb25zKTsKCiAgICBpZiAoc2VsZWN0ZWRPcHRpb24pIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0gLy8gSWYgdGhlIG9wdGlvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gcHJlZmlsdGVyZWQgdGhlbiB3ZSBjYW4gc2tpcCBmaWx0ZXJpbmcgYWdhaW5zdCB0aGUgc2VhcmNoIHZhbHVlLgogIC8vIFRPRE86IEkgc3RpbGwgZG9uJ3QgcXVpdGUgdW5kZXJzdGFuZCBob3cgdGhpcyB3b3JrcyB3aGVuIGhvb2tlZCB1cCB0byBhc3luYwoKCiAgaWYgKGlzUHJlRmlsdGVyZWQpIHsKICAgIGFjY3VtdWxhdG9yLnB1c2gob3B0aW9uKTsKICAgIHJldHVybjsKICB9CgogIGlmICghbm9ybWFsaXplZFNlYXJjaFZhbHVlKSB7CiAgICBhY2N1bXVsYXRvci5wdXNoKG9wdGlvbik7CiAgICByZXR1cm47CiAgfQoKICB2YXIgbm9ybWFsaXplZE9wdGlvbiA9IGdldFNlYXJjaGFibGVMYWJlbChvcHRpb24pOwoKICBpZiAobm9ybWFsaXplZE9wdGlvbi5pbmNsdWRlcyhub3JtYWxpemVkU2VhcmNoVmFsdWUpKSB7CiAgICBhY2N1bXVsYXRvci5wdXNoKG9wdGlvbik7CiAgfQp9OwoKZXhwb3J0IHZhciBnZXRNYXRjaGluZ09wdGlvbnMgPSBmdW5jdGlvbiBnZXRNYXRjaGluZ09wdGlvbnMob3B0aW9ucywgc2VhcmNoVmFsdWUsIGlzUHJlRmlsdGVyZWQsIHNlbGVjdGVkT3B0aW9ucykgewogIHZhciBub3JtYWxpemVkU2VhcmNoVmFsdWUgPSBzZWFyY2hWYWx1ZS50b0xvd2VyQ2FzZSgpOwogIHZhciBtYXRjaGluZ09wdGlvbnMgPSBbXTsKICBvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbikgewogICAgY29sbGVjdE1hdGNoaW5nT3B0aW9uKG1hdGNoaW5nT3B0aW9ucywgb3B0aW9uLCBub3JtYWxpemVkU2VhcmNoVmFsdWUsIGlzUHJlRmlsdGVyZWQsIHNlbGVjdGVkT3B0aW9ucyk7CiAgfSk7CiAgcmV0dXJuIG1hdGNoaW5nT3B0aW9uczsKfTs="},{"version":3,"sources":["D:/work/eui/src/components/selectable/matching_options.ts"],"names":["getSearchableLabel","option","normalize","searchableLabel","label","trim","toLowerCase","getSelectedOptionForSearchValue","searchValue","selectedOptions","normalizedSearchValue","find","collectMatchingOption","accumulator","isPreFiltered","selectedOption","push","normalizedOption","includes","getMatchingOptions","options","matchingOptions","forEach"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,IAAMA,kBAAkB,GAAG,SAArBA,kBAAqB,CACzBC,MADyB,EAGd;AAAA,MADXC,SACW,uEADU,IACV;AACX,MAAMC,eAAe,GAAGF,MAAM,CAACE,eAAP,IAA0BF,MAAM,CAACG,KAAzD;AACA,SAAOF,SAAS,GAAGC,eAAe,CAACE,IAAhB,GAAuBC,WAAvB,EAAH,GAA0CH,eAA1D;AACD,CAND;;AAQA,IAAMI,+BAA+B,GAAG,SAAlCA,+BAAkC,CACtCC,WADsC,EAEtCC,eAFsC,EAGnC;AACH,MAAMC,qBAAqB,GAAGF,WAAW,CAACF,WAAZ,EAA9B;AACA,SAAOG,eAAe,CAACE,IAAhB,CACL,UAACV,MAAD;AAAA,WAAYD,kBAAkB,CAAIC,MAAJ,CAAlB,KAAkCS,qBAA9C;AAAA,GADK,CAAP;AAGD,CARD;;AAUA,IAAME,qBAAqB,GAAG,SAAxBA,qBAAwB,CAC5BC,WAD4B,EAE5BZ,MAF4B,EAG5BS,qBAH4B,EAI5BI,aAJ4B,EAK5BL,eAL4B,EAMzB;AACH;AACA;AACA,MAAIA,eAAJ,EAAqB;AACnB,QAAMM,cAAc,GAAGR,+BAA+B,CACpDP,kBAAkB,CAAIC,MAAJ,EAAY,KAAZ,CADkC,EAEpDQ,eAFoD,CAAtD;;AAIA,QAAIM,cAAJ,EAAoB;AAClB,aAAO,KAAP;AACD;AACF,GAXE,CAaH;AACA;;;AACA,MAAID,aAAJ,EAAmB;AACjBD,IAAAA,WAAW,CAACG,IAAZ,CAAiBf,MAAjB;AACA;AACD;;AAED,MAAI,CAACS,qBAAL,EAA4B;AAC1BG,IAAAA,WAAW,CAACG,IAAZ,CAAiBf,MAAjB;AACA;AACD;;AAED,MAAMgB,gBAAgB,GAAGjB,kBAAkB,CAAIC,MAAJ,CAA3C;;AACA,MAAIgB,gBAAgB,CAACC,QAAjB,CAA0BR,qBAA1B,CAAJ,EAAsD;AACpDG,IAAAA,WAAW,CAACG,IAAZ,CAAiBf,MAAjB;AACD;AACF,CAnCD;;AAqCA,OAAO,IAAMkB,kBAAkB,GAAG,SAArBA,kBAAqB,CAIhCC,OAJgC,EAQhCZ,WARgC,EAYhCM,aAZgC,EAiBhCL,eAjBgC,EAkB7B;AACH,MAAMC,qBAAqB,GAAGF,WAAW,CAACF,WAAZ,EAA9B;AACA,MAAMe,eAA8C,GAAG,EAAvD;AAEAD,EAAAA,OAAO,CAACE,OAAR,CAAgB,UAACrB,MAAD,EAAY;AAC1BW,IAAAA,qBAAqB,CACnBS,eADmB,EAEnBpB,MAFmB,EAGnBS,qBAHmB,EAInBI,aAJmB,EAKnBL,eALmB,CAArB;AAOD,GARD;AASA,SAAOY,eAAP;AACD,CAhCM","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { EuiSelectableOption } from './selectable_option';\n\nconst getSearchableLabel = <T>(\n  option: EuiSelectableOption<T>,\n  normalize: boolean = true\n): string => {\n  const searchableLabel = option.searchableLabel || option.label;\n  return normalize ? searchableLabel.trim().toLowerCase() : searchableLabel;\n};\n\nconst getSelectedOptionForSearchValue = <T>(\n  searchValue: string,\n  selectedOptions: Array<EuiSelectableOption<T>>\n) => {\n  const normalizedSearchValue = searchValue.toLowerCase();\n  return selectedOptions.find(\n    (option) => getSearchableLabel<T>(option) === normalizedSearchValue\n  );\n};\n\nconst collectMatchingOption = <T>(\n  accumulator: Array<EuiSelectableOption<T>>,\n  option: EuiSelectableOption<T>,\n  normalizedSearchValue: string,\n  isPreFiltered?: boolean,\n  selectedOptions?: Array<EuiSelectableOption<T>>\n) => {\n  // Don't show options that have already been requested if\n  // the selectedOptions list exists\n  if (selectedOptions) {\n    const selectedOption = getSelectedOptionForSearchValue<T>(\n      getSearchableLabel<T>(option, false),\n      selectedOptions\n    );\n    if (selectedOption) {\n      return false;\n    }\n  }\n\n  // If the options have already been prefiltered then we can skip filtering against the search value.\n  // TODO: I still don't quite understand how this works when hooked up to async\n  if (isPreFiltered) {\n    accumulator.push(option);\n    return;\n  }\n\n  if (!normalizedSearchValue) {\n    accumulator.push(option);\n    return;\n  }\n\n  const normalizedOption = getSearchableLabel<T>(option);\n  if (normalizedOption.includes(normalizedSearchValue)) {\n    accumulator.push(option);\n  }\n};\n\nexport const getMatchingOptions = <T>(\n  /**\n   * All available options to match against\n   */\n  options: Array<EuiSelectableOption<T>>,\n  /**\n   * String to match option.label || option.searchableLabel against\n   */\n  searchValue: string,\n  /**\n   * Async?\n   */\n  isPreFiltered?: boolean,\n  /**\n   * To exclude selected options from the search list,\n   * pass the array of selected options\n   */\n  selectedOptions?: Array<EuiSelectableOption<T>>\n) => {\n  const normalizedSearchValue = searchValue.toLowerCase();\n  const matchingOptions: Array<EuiSelectableOption<T>> = [];\n\n  options.forEach((option) => {\n    collectMatchingOption<T>(\n      matchingOptions,\n      option,\n      normalizedSearchValue,\n      isPreFiltered,\n      selectedOptions\n    );\n  });\n  return matchingOptions;\n};\n"]}]}