{"remainingRequest":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js??ref--4-1!D:\\work\\eui\\src\\components\\datagrid\\data_grid_schema.tsx","dependencies":[{"path":"D:\\work\\eui\\src\\components\\datagrid\\data_grid_schema.tsx","mtime":1649070093366},{"path":"D:\\work\\eui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1636976621750},{"path":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js","mtime":1649070120649}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvciI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmciOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5wYXJzZS1mbG9hdCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWludCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc2V0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLm1hdGNoIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0IjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yIjsKCmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9CgpmdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH0KCmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9CgpmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH0KCmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcigiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuIik7IH0KCmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gInN0cmluZyIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSAiT2JqZWN0IiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gIk1hcCIgfHwgbiA9PT0gIlNldCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gIkFyZ3VtZW50cyIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9CgpmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICJ1bmRlZmluZWQiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9CgpmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9CgpmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0KCi8qCiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvcgogKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aAogKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodAogKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyCiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOyB5b3UgbWF5CiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAogKgogKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKICoKICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLAogKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbgogKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlCiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMKICogdW5kZXIgdGhlIExpY2Vuc2UuCiAqLwppbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JzsKaW1wb3J0IHsgRXVpSTE4biB9IGZyb20gJy4uL2kxOG4nOwp2YXIgbnVtZXJpY0NoYXJzID0gbmV3IFNldChbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLicsICctJ10pOwpleHBvcnQgdmFyIHNjaGVtYURldGVjdG9ycyA9IFt7CiAgdHlwZTogJ2Jvb2xlYW4nLAogIGRldGVjdG9yOiBmdW5jdGlvbiBkZXRlY3Rvcih2YWx1ZSkgewogICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJyB8fCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnZmFsc2UnID8gMSA6IDA7CiAgfSwKICBjb21wYXJhdG9yOiBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIGRpcmVjdGlvbikgewogICAgdmFyIGFWYWx1ZSA9IGEudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnOwogICAgdmFyIGJWYWx1ZSA9IGIudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnOwogICAgaWYgKGFWYWx1ZSA8IGJWYWx1ZSkgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAtMSA6IDE7CiAgICBpZiAoYVZhbHVlID4gYlZhbHVlKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IDEgOiAtMTsKICAgIHJldHVybiAwOwogIH0sCiAgaWNvbjogJ3Rva2VuQm9vbGVhbicsCiAgc29ydFRleHRBc2M6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEV1aUkxOG4sIHsKICAgIHRva2VuOiAiZXVpRGF0YUdyaWRTY2hlbWEuYm9vbGVhblNvcnRUZXh0QXNjIiwKICAgIGRlZmF1bHQ6ICJGYWxzZS1UcnVlIgogIH0pLAogIHNvcnRUZXh0RGVzYzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXVpSTE4biwgewogICAgdG9rZW46ICJldWlEYXRhR3JpZFNjaGVtYS5ib29sZWFuU29ydFRleHREZXNjIiwKICAgIGRlZmF1bHQ6ICJUcnVlLUZhbHNlIgogIH0pCn0sIHsKICB0eXBlOiAnY3VycmVuY3knLAogIGRldGVjdG9yOiBmdW5jdGlvbiBkZXRlY3Rvcih2YWx1ZSkgewogICAgdmFyIG1hdGNoTGVuZ3RoID0gKHZhbHVlLm1hdGNoKCAvLyBjdXJyZW5jeSBwcmVmZXJzIHN0YXJ0aW5nIHdpdGggMS0zIGNoYXJhY3RlcnMgZm9yIHRoZSBjdXJyZW5jeSBzeW1ib2wKICAgIC8vIHRoZW4gaXQgbWF0Y2hlcyBhZ2FpbnN0IG51bWVyaWNhbCBkYXRhICsgJAogICAgLyheW14tKC5dezEsM30pP1skLShdKltcZCxdKyhcLlxkKik/WyQpXSovKSB8fCBbJyddKVswXS5sZW5ndGg7IC8vIGlmIHRoZXJlIGlzIG5vIGN1cnJlbmN5IHN5bWJvbCB0aGVuIHJlZHVjZSB0aGUgc2NvcmUKCiAgICB2YXIgaGFzQ3VycmVuY3kgPSB2YWx1ZS5pbmRleE9mKCckJykgIT09IC0xOwogICAgdmFyIGNvbmZpZGVuY2VBZGp1c3RtZW50ID0gaGFzQ3VycmVuY3kgPyAxIDogMC45NTsKICAgIHJldHVybiBtYXRjaExlbmd0aCAvIHZhbHVlLmxlbmd0aCAqIGNvbmZpZGVuY2VBZGp1c3RtZW50IHx8IDA7CiAgfSwKICBjb21wYXJhdG9yOiBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIGRpcmVjdGlvbikgewogICAgdmFyIGFDaGFycyA9IGEuc3BsaXQoJycpLmZpbHRlcihmdW5jdGlvbiAoY2hhcikgewogICAgICByZXR1cm4gbnVtZXJpY0NoYXJzLmhhcyhjaGFyKTsKICAgIH0pOwogICAgdmFyIGFWYWx1ZSA9IHBhcnNlRmxvYXQoYUNoYXJzLmpvaW4oJycpKTsKICAgIHZhciBiQ2hhcnMgPSBiLnNwbGl0KCcnKS5maWx0ZXIoZnVuY3Rpb24gKGNoYXIpIHsKICAgICAgcmV0dXJuIG51bWVyaWNDaGFycy5oYXMoY2hhcik7CiAgICB9KTsKICAgIHZhciBiVmFsdWUgPSBwYXJzZUZsb2F0KGJDaGFycy5qb2luKCcnKSk7CiAgICBpZiAoYVZhbHVlIDwgYlZhbHVlKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IC0xIDogMTsKICAgIGlmIChhVmFsdWUgPiBiVmFsdWUpIHJldHVybiBkaXJlY3Rpb24gPT09ICdhc2MnID8gMSA6IC0xOwogICAgcmV0dXJuIDA7CiAgfSwKICBpY29uOiAnY3VycmVuY3knLAogIGNvbG9yOiAnZXVpQ29sb3JWaXMwJywKICBzb3J0VGV4dEFzYzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXVpSTE4biwgewogICAgdG9rZW46ICJldWlEYXRhR3JpZFNjaGVtYS5jdXJyZW5jeVNvcnRUZXh0QXNjIiwKICAgIGRlZmF1bHQ6ICJMb3ctSGlnaCIKICB9KSwKICBzb3J0VGV4dERlc2M6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEV1aUkxOG4sIHsKICAgIHRva2VuOiAiZXVpRGF0YUdyaWRTY2hlbWEuY3VycmVuY3lTb3J0VGV4dERlc2MiLAogICAgZGVmYXVsdDogIkhpZ2gtTG93IgogIH0pCn0sIHsKICB0eXBlOiAnZGF0ZXRpbWUnLAogIGRldGVjdG9yOiBmdW5jdGlvbiBkZXRlY3Rvcih2YWx1ZSkgewogICAgLy8gbWF0Y2hlcyB0aGUgbW9zdCBjb21tb24gZm9ybXMgb2YgSVNPLTg2MDEKICAgIHZhciBpc29UaW1lc3RhbXBNYXRjaCA9IHZhbHVlLm1hdGNoKCAvLyAyMDE5IC0gMDkgICAgLSAxNyAgICAgVCAxMiAgICAgOiAxOCAgICA6IDMyICAgICAgLjg1MyAgICAgWiBvciAtMDYwMAogICAgL15cZHsyLDR9LVxkezEsMn0tXGR7MSwyfShUP1xkezEsMn06XGR7MSwyfTpcZHsxLDJ9KFwuXGR7M30pPyhafFsrLV1cZHs0fSk/KT8vKTsgLy8gbWF0Y2hlcyA5IGRpZ2l0cyAoc2Vjb25kcykgb3IgMTMgZGlnaXRzIChtaWxsaXNlY29uZHMpIHNpbmNlIHVuaXggZXBvY2gKCiAgICB2YXIgdW5peFRpbWVzdGFtcE1hdGNoID0gdmFsdWUubWF0Y2goL14oXGR7OX18XGR7MTN9KSQvKTsKICAgIHZhciBpc29NYXRjaExlbmd0aCA9IGlzb1RpbWVzdGFtcE1hdGNoID8gaXNvVGltZXN0YW1wTWF0Y2hbMF0ubGVuZ3RoIDogMDsgLy8gcmVkdWNlIHRoZSBjb25maWRlbmNlIG9mIGEgdW5peCB0aW1lc3RhbXAgbWF0Y2ggdG8gNzUlCiAgICAvLyAoYSBjb2x1bW4gb2YgYWxsIHVuaXggdGltZXN0YW1wcyBzaG91bGQgYmUgbnVtZXJpYyBpbnN0ZWFkKQoKICAgIHZhciB1bml4TWF0Y2hMZW5ndGggPSB1bml4VGltZXN0YW1wTWF0Y2ggPyB1bml4VGltZXN0YW1wTWF0Y2hbMF0ubGVuZ3RoICogMC43NSA6IDA7CiAgICByZXR1cm4gTWF0aC5tYXgoaXNvTWF0Y2hMZW5ndGgsIHVuaXhNYXRjaExlbmd0aCkgLyB2YWx1ZS5sZW5ndGggfHwgMDsKICB9LAogIGljb246ICd0b2tlbkRhdGUnLAogIHNvcnRUZXh0QXNjOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFdWlJMThuLCB7CiAgICB0b2tlbjogImV1aURhdGFHcmlkU2NoZW1hLmRhdGVTb3J0VGV4dEFzYyIsCiAgICBkZWZhdWx0OiAiT2xkLU5ldyIKICB9KSwKICBzb3J0VGV4dERlc2M6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEV1aUkxOG4sIHsKICAgIHRva2VuOiAiZXVpRGF0YUdyaWRTY2hlbWEuZGF0ZVNvcnRUZXh0RGVzYyIsCiAgICBkZWZhdWx0OiAiTmV3LU9sZCIKICB9KQp9LCB7CiAgdHlwZTogJ251bWVyaWMnLAogIGRldGVjdG9yOiBmdW5jdGlvbiBkZXRlY3Rvcih2YWx1ZSkgewogICAgdmFyIG1hdGNoTGVuZ3RoID0gKHZhbHVlLm1hdGNoKC9bJS0oXSpbXGQsXSsoXC5cZCopP1slKV0qLykgfHwgWycnXSlbMF0ubGVuZ3RoOwogICAgcmV0dXJuIG1hdGNoTGVuZ3RoIC8gdmFsdWUubGVuZ3RoIHx8IDA7CiAgfSwKICBjb21wYXJhdG9yOiBmdW5jdGlvbiBjb21wYXJhdG9yKGEsIGIsIGRpcmVjdGlvbikgewogICAgLy8gc29ydCBvbiBhbGwgZGlnaXRzIGdyb3VwcwogICAgdmFyIGFHcm91cHMgPSBhLnNwbGl0KC9cRCsvKTsKICAgIHZhciBiR3JvdXBzID0gYi5zcGxpdCgvXEQrLyk7CiAgICB2YXIgbWF4R3JvdXBzID0gTWF0aC5tYXgoYUdyb3Vwcy5sZW5ndGgsIGJHcm91cHMubGVuZ3RoKTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEdyb3VwczsgaSsrKSB7CiAgICAgIC8vIGlmIEEgYW5kIEIncyBncm91cCBjb3VudHMgZGlmZmVyIGFuZCB0aGV5IG1hdGNoIHVudGlsIHRoYXQgZGlmZmVyZW5jZSwgcHJlZmVyIHdoaWNoZXZlciBpcyBzaG9ydGVyCiAgICAgIGlmIChpID49IGFHcm91cHMubGVuZ3RoKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IC0xIDogMTsKICAgICAgaWYgKGkgPj0gYkdyb3Vwcy5sZW5ndGgpIHJldHVybiBkaXJlY3Rpb24gPT09ICdhc2MnID8gMSA6IC0xOwogICAgICB2YXIgYUNoYXJzID0gYUdyb3Vwc1tpXTsKICAgICAgdmFyIGJDaGFycyA9IGJHcm91cHNbaV07CiAgICAgIHZhciBhVmFsdWUgPSBwYXJzZUludChhQ2hhcnMsIDEwKTsKICAgICAgdmFyIGJWYWx1ZSA9IHBhcnNlSW50KGJDaGFycywgMTApOwogICAgICBpZiAoYVZhbHVlIDwgYlZhbHVlKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IC0xIDogMTsKICAgICAgaWYgKGFWYWx1ZSA+IGJWYWx1ZSkgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2FzYycgPyAxIDogLTE7CiAgICB9CgogICAgcmV0dXJuIDA7CiAgfSwKICBpY29uOiAndG9rZW5OdW1iZXInLAogIHNvcnRUZXh0QXNjOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFdWlJMThuLCB7CiAgICB0b2tlbjogImV1aURhdGFHcmlkU2NoZW1hLm51bWJlclNvcnRUZXh0QXNjIiwKICAgIGRlZmF1bHQ6ICJMb3ctSGlnaCIKICB9KSwKICBzb3J0VGV4dERlc2M6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEV1aUkxOG4sIHsKICAgIHRva2VuOiAiZXVpRGF0YUdyaWRTY2hlbWEubnVtYmVyU29ydFRleHREZXNjIiwKICAgIGRlZmF1bHQ6ICJIaWdoLUxvdyIKICB9KQp9LCB7CiAgdHlwZTogJ2pzb24nLAogIGRldGVjdG9yOiBmdW5jdGlvbiBkZXRlY3Rvcih2YWx1ZSkgewogICAgLy8gZG9lcyB0aGlzIGxvb2sgbGlrZSBpdCBtaWdodCBiZSBhIEpTT04gb2JqZWN0PwogICAgdmFyIG1heWJlQXJyYXkgPSB2YWx1ZVswXSA9PT0gJ1snICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXSc7CiAgICB2YXIgbWF5YmVPYmplY3QgPSB2YWx1ZVswXSA9PT0gJ3snICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnfSc7CiAgICBpZiAoIW1heWJlQXJyYXkgJiYgIW1heWJlT2JqZWN0KSByZXR1cm4gMDsKCiAgICB0cnkgewogICAgICBKU09OLnBhcnNlKHZhbHVlKTsKICAgICAgcmV0dXJuIDE7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIHJldHVybiAwOwogICAgfQogIH0sCiAgY29tcGFyYXRvcjogZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiLCBkaXJlY3Rpb24pIHsKICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IDEgOiAtMTsKICAgIGlmIChhLmxlbmd0aCA8IGIubGVuZ3RoKSByZXR1cm4gZGlyZWN0aW9uID09PSAnYXNjJyA/IDEgOiAtMTsKICAgIHJldHVybiAwOwogIH0sCiAgaWNvbjogJ3Rva2VuT2JqZWN0JywKICBzb3J0VGV4dEFzYzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXVpSTE4biwgewogICAgdG9rZW46ICJldWlEYXRhR3JpZFNjaGVtYS5qc29uU29ydFRleHRBc2MiLAogICAgZGVmYXVsdDogIlNtYWxsLUxhcmdlIgogIH0pLAogIHNvcnRUZXh0RGVzYzogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXVpSTE4biwgewogICAgdG9rZW46ICJldWlEYXRhR3JpZFNjaGVtYS5qc29uU29ydFRleHREZXNjIiwKICAgIGRlZmF1bHQ6ICJMYXJnZS1TbWFsbCIKICB9KQp9XTsKCmZ1bmN0aW9uIHNjb3JlVmFsdWVCeVNjaGVtYVR5cGUodmFsdWUpIHsKICB2YXIgc2NoZW1hRGV0ZWN0b3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTsKICB2YXIgc2NvcmVzID0gW107CgogIGZvciAodmFyIGkgPSAwOyBpIDwgc2NoZW1hRGV0ZWN0b3JzLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgX3NjaGVtYURldGVjdG9ycyRpID0gc2NoZW1hRGV0ZWN0b3JzW2ldLAogICAgICAgIF90eXBlID0gX3NjaGVtYURldGVjdG9ycyRpLnR5cGUsCiAgICAgICAgZGV0ZWN0b3IgPSBfc2NoZW1hRGV0ZWN0b3JzJGkuZGV0ZWN0b3I7CiAgICB2YXIgc2NvcmUgPSBkZXRlY3Rvcih2YWx1ZSk7CiAgICBzY29yZXMucHVzaCh7CiAgICAgIHR5cGU6IF90eXBlLAogICAgICBzY29yZTogc2NvcmUKICAgIH0pOwogIH0KCiAgcmV0dXJuIHNjb3JlczsKfSAvLyBjb21wbGV0ZWx5IGFyYml0cmFyeSBtaW5pbXVtIG1hdGNoIEkgY2FtZSB1cCB3aXRoCi8vIHJlcHJlc2VudHMgbG93ZXN0IHNjb3JlIGEgdHlwZSBkZXRlY3RvciBjYW4gaGF2ZSB0byBiZSBjb25zaWRlcmVkIHZhbGlkCgoKdmFyIE1JTklNVU1fU0NPUkVfTUFUQ0ggPSAwLjU7CnZhciBlbXB0eUFycmF5ID0gW107IC8vIGZvciBpbi1tZW1vcnkgb2JqZWN0IHBlcm1hbmVuY2UKCmV4cG9ydCBmdW5jdGlvbiB1c2VEZXRlY3RTY2hlbWEoaW5NZW1vcnksIGluTWVtb3J5VmFsdWVzLCBzY2hlbWFEZXRlY3RvcnMsIGRlZmluZWRDb2x1bW5TY2hlbWFzLCBhdXRvRGV0ZWN0U2NoZW1hKSB7CiAgdmFyIF9pbk1lbW9yeSRza2lwQ29sdW1uczsKCiAgdmFyIGluTWVtb3J5U2tpcENvbHVtbnMgPSAoX2luTWVtb3J5JHNraXBDb2x1bW5zID0gaW5NZW1vcnkgPT09IG51bGwgfHwgaW5NZW1vcnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluTWVtb3J5LnNraXBDb2x1bW5zKSAhPT0gbnVsbCAmJiBfaW5NZW1vcnkkc2tpcENvbHVtbnMgIT09IHZvaWQgMCA/IF9pbk1lbW9yeSRza2lwQ29sdW1ucyA6IGVtcHR5QXJyYXk7CiAgdmFyIHNjaGVtYSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgewogICAgdmFyIHNjaGVtYSA9IHt9OwoKICAgIGlmIChhdXRvRGV0ZWN0U2NoZW1hID09PSBmYWxzZSkgewogICAgICByZXR1cm4gc2NoZW1hOwogICAgfQoKICAgIHZhciBjb2x1bW5TY2hlbWFzID0ge307IC8vIGZvciBlYWNoIHJvdywgc2NvcmUgZWFjaCB2YWx1ZSBieSBlYWNoIGRldGVjdG9yIGFuZCBwdXQgdGhlIHJlc3VsdHMgb24gYGNvbHVtblNjaGVtYXNgCgogICAgdmFyIHJvd0luZGljZXMgPSBPYmplY3Qua2V5cyhpbk1lbW9yeVZhbHVlcyk7CiAgICB2YXIgY29sdW1uSWRzV2l0aERlZmluZWRTY2hlbWFzID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGluTWVtb3J5U2tpcENvbHVtbnMpLCBfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXMoZGVmaW5lZENvbHVtblNjaGVtYXMpKSkpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93SW5kaWNlcy5sZW5ndGg7IGkrKykgewogICAgICB2YXIgcm93SW5kZXggPSByb3dJbmRpY2VzW2ldOwogICAgICB2YXIgcm93RGF0YSA9IGluTWVtb3J5VmFsdWVzW3Jvd0luZGV4XTsKICAgICAgdmFyIGNvbHVtbklkcyA9IE9iamVjdC5rZXlzKHJvd0RhdGEpOwoKICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2x1bW5JZHMubGVuZ3RoOyBqKyspIHsKICAgICAgICB2YXIgX2NvbHVtbklkID0gY29sdW1uSWRzW2pdOwogICAgICAgIGlmIChjb2x1bW5JZHNXaXRoRGVmaW5lZFNjaGVtYXMuaGFzKF9jb2x1bW5JZCkpIGNvbnRpbnVlOwogICAgICAgIHZhciBzY2hlbWFDb2x1bW4gPSBjb2x1bW5TY2hlbWFzW19jb2x1bW5JZF0gPSBjb2x1bW5TY2hlbWFzW19jb2x1bW5JZF0gfHwge307CgogICAgICAgIHZhciBjb2x1bW5WYWx1ZSA9IHJvd0RhdGFbX2NvbHVtbklkXS50cmltKCk7CgogICAgICAgIHZhciB2YWx1ZVNjb3JlcyA9IHNjb3JlVmFsdWVCeVNjaGVtYVR5cGUoY29sdW1uVmFsdWUsIHNjaGVtYURldGVjdG9ycyk7CgogICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdmFsdWVTY29yZXMubGVuZ3RoOyBrKyspIHsKICAgICAgICAgIHZhciB2YWx1ZVNjb3JlID0gdmFsdWVTY29yZXNba107CgogICAgICAgICAgaWYgKHNjaGVtYUNvbHVtbi5oYXNPd25Qcm9wZXJ0eSh2YWx1ZVNjb3JlLnR5cGUpKSB7CiAgICAgICAgICAgIHZhciBleGlzdGluZ1Njb3JlID0gc2NoZW1hQ29sdW1uW3ZhbHVlU2NvcmUudHlwZV07CiAgICAgICAgICAgIGV4aXN0aW5nU2NvcmUucHVzaCh2YWx1ZVNjb3JlLnNjb3JlKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIC8vIGZpcnN0IGVudHJ5IGZvciB0aGlzIGNvbHVtbgogICAgICAgICAgICBzY2hlbWFDb2x1bW5bdmFsdWVTY29yZS50eXBlXSA9IFt2YWx1ZVNjb3JlLnNjb3JlXTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0gLy8gZm9yIGVhY2ggY29sdW1uLCByZWR1Y2UgZWFjaCBkZXRlY3RvciB0eXBlJ3Mgc2NvcmUgdG8gYSBzaW5nbGUgdmFsdWUgYW5kIGZpbmQgdGhlIGJlc3QgZml0CgoKICAgIHJldHVybiBPYmplY3Qua2V5cyhjb2x1bW5TY2hlbWFzKS5yZWR1Y2UoZnVuY3Rpb24gKHNjaGVtYSwgY29sdW1uSWQpIHsKICAgICAgdmFyIGNvbHVtblNjb3JlcyA9IGNvbHVtblNjaGVtYXNbY29sdW1uSWRdOwogICAgICB2YXIgdHlwZUlkcyA9IE9iamVjdC5rZXlzKGNvbHVtblNjb3Jlcyk7CiAgICAgIHZhciB0eXBlU3VtbWFyaWVzID0ge307CiAgICAgIHZhciBiZXN0VHlwZSA9IG51bGw7CiAgICAgIHZhciBiZXN0U2NvcmUgPSAwOwoKICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHR5cGVJZHMubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgdmFyIHR5cGVJZCA9IHR5cGVJZHNbX2ldOwogICAgICAgIHZhciB0eXBlU2NvcmVzID0gY29sdW1uU2NvcmVzW3R5cGVJZF07IC8vIGZpbmQgdGhlIG1lYW4KCiAgICAgICAgdmFyIHRvdGFsU2NvcmUgPSAwOwoKICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgdHlwZVNjb3Jlcy5sZW5ndGg7IF9qKyspIHsKICAgICAgICAgIHZhciBfc2NvcmUgPSB0eXBlU2NvcmVzW19qXTsKICAgICAgICAgIHRvdGFsU2NvcmUgKz0gX3Njb3JlOwogICAgICAgIH0KCiAgICAgICAgdmFyIG1lYW4gPSB0b3RhbFNjb3JlIC8gdHlwZVNjb3Jlcy5sZW5ndGg7IC8vIGNvbXB1dGUgc3RhbmRhcmQgZGV2aWF0aW9uCgogICAgICAgIHZhciBzZFN1bSA9IDA7CgogICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IHR5cGVTY29yZXMubGVuZ3RoOyBfajIrKykgewogICAgICAgICAgdmFyIF9zY29yZTIgPSB0eXBlU2NvcmVzW19qMl07CiAgICAgICAgICBzZFN1bSArPSAoX3Njb3JlMiAtIG1lYW4pICogKF9zY29yZTIgLSBtZWFuKTsKICAgICAgICB9CgogICAgICAgIHZhciBzZCA9IE1hdGguc3FydChzZFN1bSAvIHR5cGVTY29yZXMubGVuZ3RoKTsKICAgICAgICB2YXIgc3VtbWFyeSA9IHsKICAgICAgICAgIG1lYW46IG1lYW4sCiAgICAgICAgICBzZDogc2QKICAgICAgICB9OyAvLyB0aGUgbWVhbi1zdGFuZGFyZF9kZXZpYXRpb24gY2FsY3VsYXRpb24gaXMgZmFpcmx5IGFyYml0cmFyeSBidXQgZml0cyB0aGUgcGF0dGVybnMgSSd2ZSB0aHJvd24gYXQgaXQKICAgICAgICAvLyBpdCBpcyBtZWFudCB0byByZXByZXNlbnQgdGhlIHNjb3JlcycgYXZlcmFnZSBhbmQgZGlzdHJpYnV0aW9uCgogICAgICAgIHZhciBzY29yZSA9IHN1bW1hcnkubWVhbiAtIHN1bW1hcnkuc2Q7CgogICAgICAgIGlmIChzY29yZSA+IE1JTklNVU1fU0NPUkVfTUFUQ0gpIHsKICAgICAgICAgIGlmIChiZXN0VHlwZSA9PSBudWxsIHx8IHNjb3JlID4gYmVzdFNjb3JlKSB7CiAgICAgICAgICAgIGJlc3RUeXBlID0gdHlwZUlkOwogICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHR5cGVTdW1tYXJpZXNbdHlwZUlkXSA9IHN1bW1hcnk7CiAgICAgIH0KCiAgICAgIHNjaGVtYVtjb2x1bW5JZF0gPSB7CiAgICAgICAgY29sdW1uVHlwZTogYmVzdFR5cGUKICAgICAgfTsKICAgICAgcmV0dXJuIHNjaGVtYTsKICAgIH0sIHt9KTsKICB9LCBbYXV0b0RldGVjdFNjaGVtYSwgZGVmaW5lZENvbHVtblNjaGVtYXMsIGluTWVtb3J5U2tpcENvbHVtbnMsIGluTWVtb3J5VmFsdWVzLCBzY2hlbWFEZXRlY3RvcnNdKTsKICByZXR1cm4gc2NoZW1hOwp9CmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTY2hlbWEoZGV0ZWN0ZWRTY2hlbWEsIGNvbHVtbnMpIHsKICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7CiAgICB2YXIgbWVyZ2VkU2NoZW1hID0gX29iamVjdFNwcmVhZCh7fSwgZGV0ZWN0ZWRTY2hlbWEpOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykgewogICAgICB2YXIgX2NvbHVtbnMkaSA9IGNvbHVtbnNbaV0sCiAgICAgICAgICBpZCA9IF9jb2x1bW5zJGkuaWQsCiAgICAgICAgICBzY2hlbWEgPSBfY29sdW1ucyRpLnNjaGVtYTsKCiAgICAgIGlmIChzY2hlbWEgIT0gbnVsbCkgewogICAgICAgIGlmIChkZXRlY3RlZFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShpZCkpIHsKICAgICAgICAgIG1lcmdlZFNjaGVtYVtpZF0gPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRldGVjdGVkU2NoZW1hW2lkXSksIHt9LCB7CiAgICAgICAgICAgIGNvbHVtblR5cGU6IHNjaGVtYQogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG1lcmdlZFNjaGVtYVtpZF0gPSB7CiAgICAgICAgICAgIGNvbHVtblR5cGU6IHNjaGVtYQogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gbWVyZ2VkU2NoZW1hOwogIH0sIFtkZXRlY3RlZFNjaGVtYSwgY29sdW1uc10pOwp9IC8vIEdpdmVuIGEgcHJvdmlkZWQgc2NoZW1hLCByZXR1cm4gdGhlIGRldGFpbHMgZm9yIHRoZSBzY2hlbWEKLy8gVXNlZnVsIGZvciBncmFiYmluZyB0aGUgY29sb3Igb3IgaWNvbgoKZXhwb3J0IGZ1bmN0aW9uIGdldERldGFpbHNGb3JTY2hlbWEoZGV0ZWN0b3JzLCBwcm92aWRlZFNjaGVtYSkgewogIHZhciByZXN1bHRzID0gZGV0ZWN0b3JzLmZpbHRlcihmdW5jdGlvbiAobWF0Y2hlcykgewogICAgcmV0dXJuIG1hdGNoZXMudHlwZSA9PT0gcHJvdmlkZWRTY2hlbWE7CiAgfSk7CiAgcmV0dXJuIHJlc3VsdHNbMF07Cn0="},{"version":3,"sources":["D:/work/eui/src/components/datagrid/data_grid_schema.tsx"],"names":["React","useMemo","EuiI18n","numericChars","Set","schemaDetectors","type","detector","value","toLowerCase","comparator","a","b","direction","aValue","bValue","icon","sortTextAsc","sortTextDesc","matchLength","match","length","hasCurrency","indexOf","confidenceAdjustment","aChars","split","filter","char","has","parseFloat","join","bChars","color","isoTimestampMatch","unixTimestampMatch","isoMatchLength","unixMatchLength","Math","max","aGroups","bGroups","maxGroups","i","parseInt","maybeArray","maybeObject","JSON","parse","e","scoreValueBySchemaType","scores","score","push","MINIMUM_SCORE_MATCH","emptyArray","useDetectSchema","inMemory","inMemoryValues","definedColumnSchemas","autoDetectSchema","inMemorySkipColumns","skipColumns","schema","columnSchemas","rowIndices","Object","keys","columnIdsWithDefinedSchemas","rowIndex","rowData","columnIds","j","columnId","schemaColumn","columnValue","trim","valueScores","k","valueScore","hasOwnProperty","existingScore","reduce","columnScores","typeIds","typeSummaries","bestType","bestScore","typeId","typeScores","totalScore","mean","sdSum","sd","sqrt","summary","columnType","useMergedSchema","detectedSchema","columns","mergedSchema","id","getDetailsForSchema","detectors","providedSchema","results","matches"],"mappings":"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","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React, { useMemo, ReactNode } from 'react';\nimport {\n  EuiDataGridColumn,\n  EuiDataGridInMemory,\n  EuiDataGridInMemoryValues,\n} from './data_grid_types';\n\nimport { EuiI18n } from '../i18n';\n\nimport { IconType } from '../icon';\nimport { EuiTokenProps } from '../token';\n\nexport interface EuiDataGridSchemaDetector {\n  /**\n   * The name of this data type, matches #EuiDataGridColumn / schema `schema`\n   */\n  type: string;\n  /**\n   * The function given the text value of a cell and returns a score of [0...1] of how well the value matches this data type\n   */\n  detector: (value: string) => number;\n  /**\n   * A custom comparator function when performing in-memory sorting on this data type, takes `(a: string, b: string, direction: 'asc' | 'desc) => -1 | 0 | 1`\n   */\n  comparator?: (a: string, b: string, direction: 'asc' | 'desc') => -1 | 0 | 1;\n  /**\n   * The icon used to visually represent this data type. Accepts any `EuiIcon IconType`.\n   */\n  icon: IconType;\n  /**\n   * The color associated with this data type; it's used to color the icon token\n   */\n  color?: EuiTokenProps['color'] | string;\n  /**\n   * Text for how to represent an ascending sort of this data type, e.g. 'A -> Z'\n   */\n  sortTextAsc: ReactNode;\n  /**\n   * Text for how to represent a descending sort of this data type, e.g. 'Z -> A'\n   */\n  sortTextDesc: ReactNode;\n  /**\n   * Whether this column is sortable (defaults to true)\n   */\n  isSortable?: boolean;\n  /**\n   *  This property controls the capitalization of text\n   */\n  textTransform?: 'uppercase' | 'lowercase' | 'capitalize';\n  /**\n   * Default sort direction of the column\n   */\n  defaultSortDirection?: 'asc' | 'desc';\n}\n\nconst numericChars = new Set([\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  '.',\n  '-',\n]);\nexport const schemaDetectors: EuiDataGridSchemaDetector[] = [\n  {\n    type: 'boolean',\n    detector(value) {\n      return value.toLowerCase() === 'true' || value.toLowerCase() === 'false'\n        ? 1\n        : 0;\n    },\n    comparator(a, b, direction) {\n      const aValue = a.toLowerCase() === 'true';\n      const bValue = b.toLowerCase() === 'true';\n      if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n      if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n      return 0;\n    },\n    icon: 'tokenBoolean',\n    sortTextAsc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.booleanSortTextAsc\"\n        default=\"False-True\"\n      />\n    ),\n    sortTextDesc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.booleanSortTextDesc\"\n        default=\"True-False\"\n      />\n    ),\n  },\n  {\n    type: 'currency',\n    detector(value) {\n      const matchLength = (value.match(\n        // currency prefers starting with 1-3 characters for the currency symbol\n        // then it matches against numerical data + $\n        /(^[^-(.]{1,3})?[$-(]*[\\d,]+(\\.\\d*)?[$)]*/\n      ) || [''])[0].length;\n\n      // if there is no currency symbol then reduce the score\n      const hasCurrency = value.indexOf('$') !== -1;\n      const confidenceAdjustment = hasCurrency ? 1 : 0.95;\n\n      return (matchLength / value.length) * confidenceAdjustment || 0;\n    },\n    comparator: (a, b, direction) => {\n      const aChars = a.split('').filter((char) => numericChars.has(char));\n      const aValue = parseFloat(aChars.join(''));\n\n      const bChars = b.split('').filter((char) => numericChars.has(char));\n      const bValue = parseFloat(bChars.join(''));\n\n      if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n      if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n      return 0;\n    },\n    icon: 'currency',\n    color: 'euiColorVis0',\n    sortTextAsc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.currencySortTextAsc\"\n        default=\"Low-High\"\n      />\n    ),\n    sortTextDesc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.currencySortTextDesc\"\n        default=\"High-Low\"\n      />\n    ),\n  },\n  {\n    type: 'datetime',\n    detector(value) {\n      // matches the most common forms of ISO-8601\n      const isoTimestampMatch = value.match(\n        // 2019 - 09    - 17     T 12     : 18    : 32      .853     Z or -0600\n        /^\\d{2,4}-\\d{1,2}-\\d{1,2}(T?\\d{1,2}:\\d{1,2}:\\d{1,2}(\\.\\d{3})?(Z|[+-]\\d{4})?)?/\n      );\n\n      // matches 9 digits (seconds) or 13 digits (milliseconds) since unix epoch\n      const unixTimestampMatch = value.match(/^(\\d{9}|\\d{13})$/);\n\n      const isoMatchLength = isoTimestampMatch\n        ? isoTimestampMatch[0].length\n        : 0;\n\n      // reduce the confidence of a unix timestamp match to 75%\n      // (a column of all unix timestamps should be numeric instead)\n      const unixMatchLength = unixTimestampMatch\n        ? unixTimestampMatch[0].length * 0.75\n        : 0;\n\n      return Math.max(isoMatchLength, unixMatchLength) / value.length || 0;\n    },\n    icon: 'tokenDate',\n    sortTextAsc: (\n      <EuiI18n token=\"euiDataGridSchema.dateSortTextAsc\" default=\"Old-New\" />\n    ),\n    sortTextDesc: (\n      <EuiI18n token=\"euiDataGridSchema.dateSortTextDesc\" default=\"New-Old\" />\n    ),\n  },\n  {\n    type: 'numeric',\n    detector(value) {\n      const matchLength = (value.match(/[%-(]*[\\d,]+(\\.\\d*)?[%)]*/) || [''])[0]\n        .length;\n      return matchLength / value.length || 0;\n    },\n    comparator: (a, b, direction) => {\n      // sort on all digits groups\n      const aGroups = a.split(/\\D+/);\n      const bGroups = b.split(/\\D+/);\n\n      const maxGroups = Math.max(aGroups.length, bGroups.length);\n      for (let i = 0; i < maxGroups; i++) {\n        // if A and B's group counts differ and they match until that difference, prefer whichever is shorter\n        if (i >= aGroups.length) return direction === 'asc' ? -1 : 1;\n        if (i >= bGroups.length) return direction === 'asc' ? 1 : -1;\n\n        const aChars = aGroups[i];\n        const bChars = bGroups[i];\n        const aValue = parseInt(aChars, 10);\n        const bValue = parseInt(bChars, 10);\n\n        if (aValue < bValue) return direction === 'asc' ? -1 : 1;\n        if (aValue > bValue) return direction === 'asc' ? 1 : -1;\n      }\n\n      return 0;\n    },\n    icon: 'tokenNumber',\n    sortTextAsc: (\n      <EuiI18n token=\"euiDataGridSchema.numberSortTextAsc\" default=\"Low-High\" />\n    ),\n    sortTextDesc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.numberSortTextDesc\"\n        default=\"High-Low\"\n      />\n    ),\n  },\n  {\n    type: 'json',\n    detector(value: string) {\n      // does this look like it might be a JSON object?\n      const maybeArray = value[0] === '[' && value[value.length - 1] === ']';\n      const maybeObject = value[0] === '{' && value[value.length - 1] === '}';\n      if (!maybeArray && !maybeObject) return 0;\n\n      try {\n        JSON.parse(value);\n        return 1;\n      } catch (e) {\n        return 0;\n      }\n    },\n    comparator: (a, b, direction) => {\n      if (a.length > b.length) return direction === 'asc' ? 1 : -1;\n      if (a.length < b.length) return direction === 'asc' ? 1 : -1;\n      return 0;\n    },\n    icon: 'tokenObject',\n    sortTextAsc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.jsonSortTextAsc\"\n        default=\"Small-Large\"\n      />\n    ),\n    sortTextDesc: (\n      <EuiI18n\n        token=\"euiDataGridSchema.jsonSortTextDesc\"\n        default=\"Large-Small\"\n      />\n    ),\n  },\n];\n\nexport interface EuiDataGridSchema {\n  [columnId: string]: { columnType: string | null };\n}\n\nexport interface SchemaTypeScore {\n  type: string;\n  score: number;\n}\n\nfunction scoreValueBySchemaType(\n  value: string,\n  schemaDetectors: EuiDataGridSchemaDetector[] = []\n) {\n  const scores: SchemaTypeScore[] = [];\n\n  for (let i = 0; i < schemaDetectors.length; i++) {\n    const { type, detector } = schemaDetectors[i];\n    const score = detector(value);\n    scores.push({ type, score });\n  }\n\n  return scores;\n}\n\n// completely arbitrary minimum match I came up with\n// represents lowest score a type detector can have to be considered valid\nconst MINIMUM_SCORE_MATCH = 0.5;\n\nconst emptyArray: unknown = []; // for in-memory object permanence\nexport function useDetectSchema(\n  inMemory: EuiDataGridInMemory | undefined,\n  inMemoryValues: EuiDataGridInMemoryValues,\n  schemaDetectors: EuiDataGridSchemaDetector[] | undefined,\n  definedColumnSchemas: { [key: string]: string },\n  autoDetectSchema: boolean\n) {\n  const inMemorySkipColumns =\n    inMemory?.skipColumns ??\n    (emptyArray as NonNullable<EuiDataGridInMemory['skipColumns']>);\n\n  const schema = useMemo(() => {\n    const schema: EuiDataGridSchema = {};\n    if (autoDetectSchema === false) {\n      return schema;\n    }\n\n    const columnSchemas: {\n      [columnId: string]: { [type: string]: number[] };\n    } = {};\n\n    // for each row, score each value by each detector and put the results on `columnSchemas`\n    const rowIndices = Object.keys(inMemoryValues);\n\n    const columnIdsWithDefinedSchemas = new Set<string>([\n      ...inMemorySkipColumns,\n      ...Object.keys(definedColumnSchemas),\n    ]);\n\n    for (let i = 0; i < rowIndices.length; i++) {\n      const rowIndex = rowIndices[i];\n      const rowData = inMemoryValues[rowIndex];\n      const columnIds = Object.keys(rowData);\n\n      for (let j = 0; j < columnIds.length; j++) {\n        const columnId = columnIds[j];\n        if (columnIdsWithDefinedSchemas.has(columnId)) continue;\n\n        const schemaColumn = (columnSchemas[columnId] =\n          columnSchemas[columnId] || {});\n\n        const columnValue = rowData[columnId].trim();\n        const valueScores = scoreValueBySchemaType(\n          columnValue,\n          schemaDetectors\n        );\n\n        for (let k = 0; k < valueScores.length; k++) {\n          const valueScore = valueScores[k];\n          if (schemaColumn.hasOwnProperty(valueScore.type)) {\n            const existingScore = schemaColumn[valueScore.type];\n            existingScore.push(valueScore.score);\n          } else {\n            // first entry for this column\n            schemaColumn[valueScore.type] = [valueScore.score];\n          }\n        }\n      }\n    }\n\n    // for each column, reduce each detector type's score to a single value and find the best fit\n    return Object.keys(columnSchemas).reduce<EuiDataGridSchema | any>(\n      (schema, columnId) => {\n        const columnScores = columnSchemas[columnId];\n        const typeIds = Object.keys(columnScores);\n\n        const typeSummaries: {\n          [type: string]: {\n            mean: number;\n            sd: number;\n          };\n        } = {};\n\n        let bestType = null;\n        let bestScore = 0;\n\n        for (let i = 0; i < typeIds.length; i++) {\n          const typeId = typeIds[i];\n\n          const typeScores = columnScores[typeId];\n\n          // find the mean\n          let totalScore = 0;\n          for (let j = 0; j < typeScores.length; j++) {\n            const score = typeScores[j];\n            totalScore += score;\n          }\n          const mean = totalScore / typeScores.length;\n\n          // compute standard deviation\n          let sdSum = 0;\n          for (let j = 0; j < typeScores.length; j++) {\n            const score = typeScores[j];\n            sdSum += (score - mean) * (score - mean);\n          }\n          const sd = Math.sqrt(sdSum / typeScores.length);\n\n          const summary = { mean, sd };\n\n          // the mean-standard_deviation calculation is fairly arbitrary but fits the patterns I've thrown at it\n          // it is meant to represent the scores' average and distribution\n          const score = summary.mean - summary.sd;\n          if (score > MINIMUM_SCORE_MATCH) {\n            if (bestType == null || score > bestScore) {\n              bestType = typeId;\n              bestScore = score;\n            }\n          }\n\n          typeSummaries[typeId] = summary;\n        }\n        schema[columnId] = { columnType: bestType };\n\n        return schema;\n      },\n      {}\n    );\n  }, [\n    autoDetectSchema,\n    definedColumnSchemas,\n    inMemorySkipColumns,\n    inMemoryValues,\n    schemaDetectors,\n  ]);\n  return schema;\n}\n\nexport function useMergedSchema(\n  detectedSchema: EuiDataGridSchema,\n  columns: EuiDataGridColumn[]\n) {\n  return useMemo(() => {\n    const mergedSchema = { ...detectedSchema };\n\n    for (let i = 0; i < columns.length; i++) {\n      const { id, schema } = columns[i];\n      if (schema != null) {\n        if (detectedSchema.hasOwnProperty(id)) {\n          mergedSchema[id] = { ...detectedSchema[id], columnType: schema };\n        } else {\n          mergedSchema[id] = { columnType: schema };\n        }\n      }\n    }\n\n    return mergedSchema;\n  }, [detectedSchema, columns]);\n}\n\n// Given a provided schema, return the details for the schema\n// Useful for grabbing the color or icon\nexport function getDetailsForSchema(\n  detectors: EuiDataGridSchemaDetector[],\n  providedSchema: string | null\n) {\n  const results = detectors.filter((matches) => {\n    return matches.type === providedSchema;\n  });\n\n  return results[0];\n}\n"]}]}