{"remainingRequest":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js??ref--4-1!D:\\work\\eui\\src\\services\\breakpoint.ts","dependencies":[{"path":"D:\\work\\eui\\src\\services\\breakpoint.ts","mtime":1649070093827},{"path":"D:\\work\\eui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1636976621750},{"path":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js","mtime":1649070120649}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZCI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzIjsKCi8qCiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvcgogKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aAogKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodAogKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyCiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAiTGljZW5zZSIpOyB5b3UgbWF5CiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuCiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdAogKgogKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjAKICoKICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLAogKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbgogKiAiQVMgSVMiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkKICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlCiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMKICogdW5kZXIgdGhlIExpY2Vuc2UuCiAqLwppbXBvcnQgeyBrZXlzT2YgfSBmcm9tICcuLi9jb21wb25lbnRzL2NvbW1vbic7CmV4cG9ydCB2YXIgQlJFQUtQT0lOVFMgPSB7CiAgeGw6IDEyMDAsCiAgbDogOTkyLAogIG06IDc2OCwKICBzOiA1NzUsCiAgeHM6IDAKfTsKZXhwb3J0IHZhciBCUkVBS1BPSU5UX0tFWVMgPSBrZXlzT2YoQlJFQUtQT0lOVFMpOwovKioKICogR2l2ZW4gdGhlIGN1cnJlbnQgYHdpZHRoYCBhbmQgYW4gb2JqZWN0IG9mIGBFdWlCcmVha3BvaW50c2AsCiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgc3RyaW5nIHRoYXQgaXMgdGhlIG5hbWUgb2YgdGhlIGJyZWFrcG9pbnQga2V5CiAqIHRoYXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB3aWR0aAogKgogKiBAcGFyYW0ge251bWJlcn0gd2lkdGggQ2FuIGVpdGhlciBiZSB0aGUgZnVsbCB3aW5kb3cgd2lkdGggb3IgYW55IHdpZHRoCiAqIEBwYXJhbSB7RXVpQnJlYWtwb2ludHN9IGJyZWFrcG9pbnRzIEFuIG9iamVjdCB3aXRoIGtleXMgZm9yIHNpemluZyBhbmQgdmFsdWVzIGZvciBtaW5pbXVtIHdpZHRoCiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQga2V5IG9yIGB1bmRlZmluZWRgIGlmIGEga2V5IGRvZXNuJ3QgZXhpc3QKICovCgpleHBvcnQgZnVuY3Rpb24gZ2V0QnJlYWtwb2ludCh3aWR0aCkgewogIHZhciBicmVha3BvaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogQlJFQUtQT0lOVFM7CiAgLy8gRmluZCB0aGUgYnJlYWtwb2ludCAoa2V5KSB3aG9zZSB2YWx1ZSBpcyA8PSB3aW5kb3dXaWR0aCBzdGFydGluZyB3aXRoIGxhcmdlc3QgZmlyc3QKICByZXR1cm4ga2V5c09mKEJSRUFLUE9JTlRTKS5maW5kKGZ1bmN0aW9uIChrZXkpIHsKICAgIHJldHVybiBicmVha3BvaW50c1trZXldIDw9IHdpZHRoOwogIH0pOwp9Ci8qKgogKiBHaXZlbiB0aGUgY3VycmVudCBgd2lkdGhgIGFuZCBhIG1heCBicmVha3BvaW50IGtleSwKICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgdGhlIGB3aWR0aGAgZmFsbHMgd2l0aGluIHRoZSBtYXgKICogYnJlYWtwb2ludCBvciBhbnkgYnJlYWtwb2ludHMgYmVsb3cKICoKICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIENhbiBlaXRoZXIgYmUgdGhlIGZ1bGwgd2luZG93IHdpZHRoIG9yIGFueSB3aWR0aAogKiBAcGFyYW0ge0V1aUJyZWFrcG9pbnRTaXplIHwgbnVtYmVyfSBtYXggVGhlIG5hbWVkIGJyZWFrcG9pbnQgb3IgY3VzdG9tIG51bWJlciB0byBjaGVjayBhZ2FpbnN0CiAqIEBwYXJhbSB7RXVpQnJlYWtwb2ludHN9IGJyZWFrcG9pbnRzIEFuIG9iamVjdCB3aXRoIGtleXMgZm9yIHNpemluZyBhbmQgdmFsdWVzIGZvciBtaW5pbXVtIHdpZHRoCiAqIEByZXR1cm5zIHtib29sZWFufSBXaWxsIHJldHVybiBgZmFsc2VgIGlmIGl0IGNhbid0IGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGBtYXhgIGJyZWFrcG9pbnQKICovCgpleHBvcnQgZnVuY3Rpb24gaXNXaXRoaW5NYXhCcmVha3BvaW50KHdpZHRoLCBtYXgpIHsKICB2YXIgYnJlYWtwb2ludHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEJSRUFLUE9JTlRTOwoKICBpZiAodHlwZW9mIG1heCA9PT0gJ251bWJlcicpIHsKICAgIHJldHVybiB3aWR0aCA8PSBtYXg7CiAgfSBlbHNlIHsKICAgIHZhciBjdXJyZW50QnJlYWtwb2ludCA9IGdldEJyZWFrcG9pbnQod2lkdGgsIGJyZWFrcG9pbnRzKTsKICAgIHJldHVybiBjdXJyZW50QnJlYWtwb2ludCA/IGJyZWFrcG9pbnRzW2N1cnJlbnRCcmVha3BvaW50XSA8PSBicmVha3BvaW50c1ttYXhdIDogZmFsc2U7CiAgfQp9Ci8qKgogKiBHaXZlbiB0aGUgY3VycmVudCBgd2lkdGhgIGFuZCBhIG1heCBicmVha3BvaW50IGtleSwKICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgdGhlIGB3aWR0aGAgZmFsbHMgd2l0aGluIHRoZSBtYXgKICogYnJlYWtwb2ludCBvciBhbnkgYnJlYWtwb2ludHMgYmVsb3cKICoKICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIENhbiBlaXRoZXIgYmUgdGhlIGZ1bGwgd2luZG93IHdpZHRoIG9yIGFueSB3aWR0aAogKiBAcGFyYW0ge0V1aUJyZWFrcG9pbnRTaXplIHwgbnVtYmVyfSBtaW4gVGhlIG5hbWVkIGJyZWFrcG9pbnQgb3IgY3VzdG9tIG51bWJlciB0byBjaGVjayBhZ2FpbnN0CiAqIEBwYXJhbSB7RXVpQnJlYWtwb2ludHN9IGJyZWFrcG9pbnRzIEFuIG9iamVjdCB3aXRoIGtleXMgZm9yIHNpemluZyBhbmQgdmFsdWVzIGZvciBtaW5pbXVtIHdpZHRoCiAqIEByZXR1cm5zIHtib29sZWFufSBXaWxsIHJldHVybiBgZmFsc2VgIGlmIGl0IGNhbid0IGZpbmQgYSB2YWx1ZSBmb3IgdGhlIGBtaW5gIGJyZWFrcG9pbnQKICovCgpleHBvcnQgZnVuY3Rpb24gaXNXaXRoaW5NaW5CcmVha3BvaW50KHdpZHRoLCBtaW4pIHsKICB2YXIgYnJlYWtwb2ludHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEJSRUFLUE9JTlRTOwoKICBpZiAodHlwZW9mIG1pbiA9PT0gJ251bWJlcicpIHsKICAgIHJldHVybiB3aWR0aCA+PSBtaW47CiAgfSBlbHNlIHsKICAgIHZhciBjdXJyZW50QnJlYWtwb2ludCA9IGdldEJyZWFrcG9pbnQod2lkdGgsIGJyZWFrcG9pbnRzKTsKICAgIHJldHVybiBjdXJyZW50QnJlYWtwb2ludCA/IGJyZWFrcG9pbnRzW2N1cnJlbnRCcmVha3BvaW50XSA+PSBicmVha3BvaW50c1ttaW5dIDogZmFsc2U7CiAgfQp9Ci8qKgogKiBHaXZlbiB0aGUgY3VycmVudCBgd2lkdGhgIGFuZCBhbiBhcnJheSBvZiBicmVha3BvaW50IGtleXMsCiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHRoZSBgd2lkdGhgIGZhbGxzIHdpdGhpbgogKiBhbnkgb2YgdGhlIG5hbWVkIGJyZWFrcG9pbnRzCiAqCiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBDYW4gZWl0aGVyIGJlIHRoZSBmdWxsIHdpbmRvdyB3aWR0aCBvciBhbnkgd2lkdGgKICogQHBhcmFtIHtFdWlCcmVha3BvaW50U2l6ZVtdfSBzaXplcyBBbiBhcnJheSBvZiBuYW1lZCBicmVha3BvaW50cwogKiBAcGFyYW0ge0V1aUJyZWFrcG9pbnRzfSBicmVha3BvaW50cyBBbiBvYmplY3Qgd2l0aCBrZXlzIGZvciBzaXppbmcgYW5kIHZhbHVlcyBmb3IgbWluaW11bSB3aWR0aAogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgY3VycmVudCBicmVha3BvaW50IG5hbWUgaXMgaW5jbHVkZWQgaW4gYHNpemVzYAogKi8KCmV4cG9ydCBmdW5jdGlvbiBpc1dpdGhpbkJyZWFrcG9pbnRzKHdpZHRoLCBzaXplcykgewogIHZhciBicmVha3BvaW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogQlJFQUtQT0lOVFM7CiAgdmFyIGN1cnJlbnRCcmVha3BvaW50ID0gZ2V0QnJlYWtwb2ludCh3aWR0aCwgYnJlYWtwb2ludHMpOwogIHJldHVybiBjdXJyZW50QnJlYWtwb2ludCA/IHNpemVzLmluY2x1ZGVzKGN1cnJlbnRCcmVha3BvaW50KSA6IGZhbHNlOwp9Cgp0cnkgewogIGdldEJyZWFrcG9pbnQuX19kb2NnZW5JbmZvID0gewogICAgZGVzY3JpcHRpb246ICdHaXZlbiB0aGUgY3VycmVudCBgd2lkdGhgIGFuZCBhbiBvYmplY3Qgb2YgYEV1aUJyZWFrcG9pbnRzYCxcbicgKyAndGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBzdHJpbmcgdGhhdCBpcyB0aGUgbmFtZSBvZiB0aGUgYnJlYWtwb2ludCBrZXlcbicgKyAndGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHdpZHRoJywKICAgIGRpc3BsYXlOYW1lOiAnZ2V0QnJlYWtwb2ludCcsCiAgICBtZXRob2RzOiBbXSwKICAgIHByb3BzOiB7fSwKICAgIGV4dGVuZGVkSW50ZXJmYWNlczogW10KICB9Owp9IGNhdGNoIChlKSB7fQoKdHJ5IHsKICBpc1dpdGhpbk1heEJyZWFrcG9pbnQuX19kb2NnZW5JbmZvID0gewogICAgZGVzY3JpcHRpb246ICdHaXZlbiB0aGUgY3VycmVudCBgd2lkdGhgIGFuZCBhIG1heCBicmVha3BvaW50IGtleSxcbicgKyAndGhpcyBmdW5jdGlvbiByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgdGhlIGB3aWR0aGAgZmFsbHMgd2l0aGluIHRoZSBtYXhcbicgKyAnYnJlYWtwb2ludCBvciBhbnkgYnJlYWtwb2ludHMgYmVsb3cnLAogICAgZGlzcGxheU5hbWU6ICdpc1dpdGhpbk1heEJyZWFrcG9pbnQnLAogICAgbWV0aG9kczogW10sCiAgICBwcm9wczoge30sCiAgICBleHRlbmRlZEludGVyZmFjZXM6IFtdCiAgfTsKfSBjYXRjaCAoZSkge30KCnRyeSB7CiAgaXNXaXRoaW5NaW5CcmVha3BvaW50Ll9fZG9jZ2VuSW5mbyA9IHsKICAgIGRlc2NyaXB0aW9uOiAnR2l2ZW4gdGhlIGN1cnJlbnQgYHdpZHRoYCBhbmQgYSBtYXggYnJlYWtwb2ludCBrZXksXG4nICsgJ3RoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHRoZSBgd2lkdGhgIGZhbGxzIHdpdGhpbiB0aGUgbWF4XG4nICsgJ2JyZWFrcG9pbnQgb3IgYW55IGJyZWFrcG9pbnRzIGJlbG93JywKICAgIGRpc3BsYXlOYW1lOiAnaXNXaXRoaW5NaW5CcmVha3BvaW50JywKICAgIG1ldGhvZHM6IFtdLAogICAgcHJvcHM6IHt9LAogICAgZXh0ZW5kZWRJbnRlcmZhY2VzOiBbXQogIH07Cn0gY2F0Y2ggKGUpIHt9Cgp0cnkgewogIGlzV2l0aGluQnJlYWtwb2ludHMuX19kb2NnZW5JbmZvID0gewogICAgZGVzY3JpcHRpb246ICdHaXZlbiB0aGUgY3VycmVudCBgd2lkdGhgIGFuZCBhbiBhcnJheSBvZiBicmVha3BvaW50IGtleXMsXG4nICsgJ3RoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIHRoZSBgd2lkdGhgIGZhbGxzIHdpdGhpblxuJyArICdhbnkgb2YgdGhlIG5hbWVkIGJyZWFrcG9pbnRzJywKICAgIGRpc3BsYXlOYW1lOiAnaXNXaXRoaW5CcmVha3BvaW50cycsCiAgICBtZXRob2RzOiBbXSwKICAgIHByb3BzOiB7fSwKICAgIGV4dGVuZGVkSW50ZXJmYWNlczogW10KICB9Owp9IGNhdGNoIChlKSB7fQ=="},{"version":3,"sources":["D:/work/eui/src/services/breakpoint.ts"],"names":["keysOf","BREAKPOINTS","xl","l","m","s","xs","BREAKPOINT_KEYS","getBreakpoint","width","breakpoints","find","key","isWithinMaxBreakpoint","max","currentBreakpoint","isWithinMinBreakpoint","min","isWithinBreakpoints","sizes","includes"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,MAAT,QAAuB,sBAAvB;AAWA,OAAO,IAAMC,WAA2B,GAAG;AACzCC,EAAAA,EAAE,EAAE,IADqC;AAEzCC,EAAAA,CAAC,EAAE,GAFsC;AAGzCC,EAAAA,CAAC,EAAE,GAHsC;AAIzCC,EAAAA,CAAC,EAAE,GAJsC;AAKzCC,EAAAA,EAAE,EAAE;AALqC,CAApC;AAQP,OAAO,IAAMC,eAAe,GAAGP,MAAM,CAACC,WAAD,CAA9B;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,aAAT,CACLC,KADK,EAG0B;AAAA,MAD/BC,WAC+B,uEADDT,WACC;AAC/B;AACA,SAAOD,MAAM,CAACC,WAAD,CAAN,CAAoBU,IAApB,CAAyB,UAACC,GAAD;AAAA,WAASF,WAAW,CAACE,GAAD,CAAX,IAAoBH,KAA7B;AAAA,GAAzB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,qBAAT,CACLJ,KADK,EAELK,GAFK,EAII;AAAA,MADTJ,WACS,uEADqBT,WACrB;;AACT,MAAI,OAAOa,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAOL,KAAK,IAAIK,GAAhB;AACD,GAFD,MAEO;AACL,QAAMC,iBAAiB,GAAGP,aAAa,CAACC,KAAD,EAAQC,WAAR,CAAvC;AACA,WAAOK,iBAAiB,GACpBL,WAAW,CAACK,iBAAD,CAAX,IAAkCL,WAAW,CAACI,GAAD,CADzB,GAEpB,KAFJ;AAGD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASE,qBAAT,CACLP,KADK,EAELQ,GAFK,EAII;AAAA,MADTP,WACS,uEADqBT,WACrB;;AACT,MAAI,OAAOgB,GAAP,KAAe,QAAnB,EAA6B;AAC3B,WAAOR,KAAK,IAAIQ,GAAhB;AACD,GAFD,MAEO;AACL,QAAMF,iBAAiB,GAAGP,aAAa,CAACC,KAAD,EAAQC,WAAR,CAAvC;AACA,WAAOK,iBAAiB,GACpBL,WAAW,CAACK,iBAAD,CAAX,IAAkCL,WAAW,CAACO,GAAD,CADzB,GAEpB,KAFJ;AAGD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,mBAAT,CACLT,KADK,EAELU,KAFK,EAII;AAAA,MADTT,WACS,uEADqBT,WACrB;AACT,MAAMc,iBAAiB,GAAGP,aAAa,CAACC,KAAD,EAAQC,WAAR,CAAvC;AACA,SAAOK,iBAAiB,GAAGI,KAAK,CAACC,QAAN,CAAeL,iBAAf,CAAH,GAAuC,KAA/D;AACD","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { keysOf } from '../components/common';\n\nexport type EuiBreakpointSize = 'xs' | 's' | 'm' | 'l' | 'xl';\n\nexport type EuiBreakpoints = {\n  /**\n   * Set the minimum window width at which to start to the breakpoint\n   */\n  [key in EuiBreakpointSize]: number;\n};\n\nexport const BREAKPOINTS: EuiBreakpoints = {\n  xl: 1200,\n  l: 992,\n  m: 768,\n  s: 575,\n  xs: 0,\n};\n\nexport const BREAKPOINT_KEYS = keysOf(BREAKPOINTS);\n\n/**\n * Given the current `width` and an object of `EuiBreakpoints`,\n * this function returns the string that is the name of the breakpoint key\n * that is less than or equal to the width\n *\n * @param {number} width Can either be the full window width or any width\n * @param {EuiBreakpoints} breakpoints An object with keys for sizing and values for minimum width\n * @returns {string | undefined} Name of the breakpoint key or `undefined` if a key doesn't exist\n */\nexport function getBreakpoint(\n  width: number,\n  breakpoints: EuiBreakpoints = BREAKPOINTS\n): EuiBreakpointSize | undefined {\n  // Find the breakpoint (key) whose value is <= windowWidth starting with largest first\n  return keysOf(BREAKPOINTS).find((key) => breakpoints[key] <= width);\n}\n\n/**\n * Given the current `width` and a max breakpoint key,\n * this function returns true or false if the `width` falls within the max\n * breakpoint or any breakpoints below\n *\n * @param {number} width Can either be the full window width or any width\n * @param {EuiBreakpointSize | number} max The named breakpoint or custom number to check against\n * @param {EuiBreakpoints} breakpoints An object with keys for sizing and values for minimum width\n * @returns {boolean} Will return `false` if it can't find a value for the `max` breakpoint\n */\nexport function isWithinMaxBreakpoint(\n  width: number,\n  max: EuiBreakpointSize | number,\n  breakpoints: EuiBreakpoints = BREAKPOINTS\n): boolean {\n  if (typeof max === 'number') {\n    return width <= max;\n  } else {\n    const currentBreakpoint = getBreakpoint(width, breakpoints);\n    return currentBreakpoint\n      ? breakpoints[currentBreakpoint] <= breakpoints[max]\n      : false;\n  }\n}\n\n/**\n * Given the current `width` and a max breakpoint key,\n * this function returns true or false if the `width` falls within the max\n * breakpoint or any breakpoints below\n *\n * @param {number} width Can either be the full window width or any width\n * @param {EuiBreakpointSize | number} min The named breakpoint or custom number to check against\n * @param {EuiBreakpoints} breakpoints An object with keys for sizing and values for minimum width\n * @returns {boolean} Will return `false` if it can't find a value for the `min` breakpoint\n */\nexport function isWithinMinBreakpoint(\n  width: number,\n  min: EuiBreakpointSize | number,\n  breakpoints: EuiBreakpoints = BREAKPOINTS\n): boolean {\n  if (typeof min === 'number') {\n    return width >= min;\n  } else {\n    const currentBreakpoint = getBreakpoint(width, breakpoints);\n    return currentBreakpoint\n      ? breakpoints[currentBreakpoint] >= breakpoints[min]\n      : false;\n  }\n}\n\n/**\n * Given the current `width` and an array of breakpoint keys,\n * this function returns true or false if the `width` falls within\n * any of the named breakpoints\n *\n * @param {number} width Can either be the full window width or any width\n * @param {EuiBreakpointSize[]} sizes An array of named breakpoints\n * @param {EuiBreakpoints} breakpoints An object with keys for sizing and values for minimum width\n * @returns {boolean} Returns `true` if current breakpoint name is included in `sizes`\n */\nexport function isWithinBreakpoints(\n  width: number,\n  sizes: EuiBreakpointSize[],\n  breakpoints: EuiBreakpoints = BREAKPOINTS\n): boolean {\n  const currentBreakpoint = getBreakpoint(width, breakpoints);\n  return currentBreakpoint ? sizes.includes(currentBreakpoint) : false;\n}\n"]}]}