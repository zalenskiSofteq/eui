{"remainingRequest":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js??ref--4-1!D:\\work\\eui\\src\\services\\popover\\popover_positioning.ts","dependencies":[{"path":"D:\\work\\eui\\src\\services\\popover\\popover_positioning.ts","mtime":1649070093846},{"path":"D:\\work\\eui\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1636976621750},{"path":"D:\\work\\eui\\node_modules\\babel-loader\\lib\\index.js","mtime":1649070120649}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmV2ZXJzZSI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWludCI7CgpmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfQoKZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH0KCmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuIik7IH0KCmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gInN0cmluZyIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSAiT2JqZWN0IiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gIk1hcCIgfHwgbiA9PT0gIlNldCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gIkFyZ3VtZW50cyIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9CgpmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0KCmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICJ1bmRlZmluZWQiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsicmV0dXJuIl0gIT0gbnVsbCkgX2lbInJldHVybiJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfQoKZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9CgovKgogKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IKICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGgKICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQKICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlcgogKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgIkxpY2Vuc2UiKTsgeW91IG1heQogKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLgogKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQKICoKICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wCiAqCiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywKICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4KICogIkFTIElTIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZCiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZQogKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zCiAqIHVuZGVyIHRoZSBMaWNlbnNlLgogKi8KZXhwb3J0IHZhciBQT1NJVElPTlMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddOwp2YXIgcmVsYXRlZERpbWVuc2lvbiA9IHsKICB0b3A6ICdoZWlnaHQnLAogIHJpZ2h0OiAnd2lkdGgnLAogIGJvdHRvbTogJ2hlaWdodCcsCiAgbGVmdDogJ3dpZHRoJwp9Owp2YXIgZGltZW5zaW9uUG9zaXRpb25BdHRyaWJ1dGUgPSB7CiAgaGVpZ2h0OiAndG9wJywKICB3aWR0aDogJ2xlZnQnCn07CnZhciBwb3NpdGlvbkNvbXBsZW1lbnRzID0gewogIHRvcDogJ2JvdHRvbScsCiAgcmlnaHQ6ICdsZWZ0JywKICBib3R0b206ICd0b3AnLAogIGxlZnQ6ICdyaWdodCcKfTsgLy8gYWx3YXlzIHJlc29sdmluZyB0byB0b3AvbGVmdCBpcyB0YWtlbiBhZHZhbnRhZ2Ugb2YgYnkga25vd2luZyB0aGV5IGFyZSB0aGUKLy8gbWluaW11bSBlZGdlcyBvZiB0aGUgYm91bmRpbmcgYm94Cgp2YXIgcG9zaXRpb25TdWJzdGl0dXRlcyA9IHsKICB0b3A6ICdsZWZ0JywKICByaWdodDogJ3RvcCcsCiAgYm90dG9tOiAnbGVmdCcsCiAgbGVmdDogJ3RvcCcKfTsKCnZhciBnZXRCdWZmZXJWYWx1ZXMgPSBmdW5jdGlvbiBnZXRCdWZmZXJWYWx1ZXMoYnVmZmVyKSB7CiAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSkgewogICAgdmFyIF9idWZmZXIgPSBfc2xpY2VkVG9BcnJheShidWZmZXIsIDQpLAogICAgICAgIHRvcEJ1ZmZlciA9IF9idWZmZXJbMF0sCiAgICAgICAgcmlnaHRCdWZmZXIgPSBfYnVmZmVyWzFdLAogICAgICAgIGJvdHRvbUJ1ZmZlciA9IF9idWZmZXJbMl0sCiAgICAgICAgbGVmdEJ1ZmZlciA9IF9idWZmZXJbM107CgogICAgcmV0dXJuIFt0b3BCdWZmZXIsIHJpZ2h0QnVmZmVyLCBib3R0b21CdWZmZXIsIGxlZnRCdWZmZXJdOwogIH0KCiAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlciwgYnVmZmVyLCBidWZmZXJdOwp9OwovKioKICogQ2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgcG9zaXRpb25pbmcgKHJlbGF0aXZlIHRvIGRvY3VtZW50LmJvZHkpIHRvIHBsYWNlIGEgcG9wb3ZlciBlbGVtZW50CiAqCiAqIEBwYXJhbSBhbmNob3Ige0hUTUxFbGVtZW50fSBFbGVtZW50IHRvIGFuY2hvciB0aGUgcG9wb3ZlciB0bwogKiBAcGFyYW0gcG9wb3ZlciB7SFRNTEVsZW1lbnR9IEVsZW1lbnQgY29udGFpbmluZyB0aGUgcG9wb3ZlciBjb250ZW50CiAqIEBwYXJhbSBwb3NpdGlvbiB7c3RyaW5nfSBQb3NpdGlvbiB0aGUgdXNlciB3YW50cy4gT25lIG9mIFsidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0Il0KICogQHBhcmFtIFtmb3JjZVBvc2l0aW9uXSB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdXNlIG9ubHkgdGhlIHByb3ZpZGVkIGBwb3NpdGlvbmAgdmFsdWUgYW5kIGRvbid0IHRyeSBhbnkgb3RoZXIgcG9zaXRpb24KICogQHBhcmFtIFthbGlnbl0ge3N0cmluZ30gQ3Jvc3MtYXhpcyBhbGlnbm1lbnQuIE9uZSBvZiBbInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCJdCiAqIEBwYXJhbSBbYnVmZmVyPTE2XSB7bnVtYmVyfSBNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvcG92ZXIgYW5kIHRoZSBib3VuZGluZyBjb250YWluZXIKICogQHBhcmFtIFtvZmZzZXQ9MF0ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9wb3ZlciBhbmQgdGhlIGFuY2hvcgogKiBAcGFyYW0gW2FsbG93Q3Jvc3NBeGlzPXRydWVdIHtib29sZWFufSBXaGV0aGVyIHRvIGFsbG93IHRoZSBwb3BvdmVyIHRvIGJlIHBvc2l0aW9uZWQgb24gdGhlIGNyb3NzLWF4aXMKICogQHBhcmFtIFtjb250YWluZXJdIHtIVE1MRWxlbWVudH0gRWxlbWVudCB0aGUgcG9wb3ZlciBtdXN0IGJlIGNvbnN0cmFpbmVkIHRvIGZpdCB3aXRoaW4KICogQHBhcmFtIFthcnJvd0NvbmZpZ10ge3thcnJvd1dpZHRoOiBudW1iZXIsIGFycm93QnVmZmVyOiBudW1iZXJ9fSBJZgogKiAgcHJlc2VudCwgZGVzY3JpYmVzIHRoZSBzaXplICYgY29uc3RyYWludHMgZm9yIGFuIGFycm93IGVsZW1lbnQsIGFuZCB0aGUKICogIGZ1bmN0aW9uIHJldHVybiB2YWx1ZSB3aWxsIGluY2x1ZGUgYW4gYGFycm93YCBwYXJhbSB3aXRoIHBvc2l0aW9uIGRldGFpbHMKICoKICogQHJldHVybnMge0ZpbmRQb3BvdmVyUG9zaXRpb25SZXN1bHR9IGFic29sdXRlIHBhZ2UgY29vcmRpbmF0ZXMgZm9yIHRoZQogKiBwb3BvdmVyLCBhbmQgdGhlIHBsYWNlbWVudCdzIHJlbGF0aW9uIHRvIHRoZSBhbmNob3Igb3IgdW5kZWZpbmVkCiAqIHRoZXJlJ3Mgbm8gcm9vbS4KICovCgoKZXhwb3J0IGZ1bmN0aW9uIGZpbmRQb3BvdmVyUG9zaXRpb24oX3JlZikgewogIHZhciBhbmNob3IgPSBfcmVmLmFuY2hvciwKICAgICAgcG9wb3ZlciA9IF9yZWYucG9wb3ZlciwKICAgICAgYWxpZ24gPSBfcmVmLmFsaWduLAogICAgICBwb3NpdGlvbiA9IF9yZWYucG9zaXRpb24sCiAgICAgIGZvcmNlUG9zaXRpb24gPSBfcmVmLmZvcmNlUG9zaXRpb24sCiAgICAgIF9yZWYkYnVmZmVyID0gX3JlZi5idWZmZXIsCiAgICAgIGJ1ZmZlciA9IF9yZWYkYnVmZmVyID09PSB2b2lkIDAgPyAxNiA6IF9yZWYkYnVmZmVyLAogICAgICBfcmVmJG9mZnNldCA9IF9yZWYub2Zmc2V0LAogICAgICBvZmZzZXQgPSBfcmVmJG9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkb2Zmc2V0LAogICAgICBfcmVmJGFsbG93Q3Jvc3NBeGlzID0gX3JlZi5hbGxvd0Nyb3NzQXhpcywKICAgICAgYWxsb3dDcm9zc0F4aXMgPSBfcmVmJGFsbG93Q3Jvc3NBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRhbGxvd0Nyb3NzQXhpcywKICAgICAgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsCiAgICAgIGFycm93Q29uZmlnID0gX3JlZi5hcnJvd0NvbmZpZywKICAgICAgcmV0dXJuQm91bmRpbmdCb3ggPSBfcmVmLnJldHVybkJvdW5kaW5nQm94OwogIC8vIGZpbmQgdGhlIHNjcmVlbi1yZWxhdGl2ZSBib3VuZGluZyBib3hlcyBvZiB0aGUgYW5jaG9yLCBwb3BvdmVyLCBhbmQgY29udGFpbmVyCiAgdmFyIGFuY2hvckJvdW5kaW5nQm94ID0gZ2V0RWxlbWVudEJvdW5kaW5nQm94KGFuY2hvcik7CiAgdmFyIHBvcG92ZXJCb3VuZGluZ0JveCA9IGdldEVsZW1lbnRCb3VuZGluZ0JveChwb3BvdmVyKTsgLy8gY2FsY3VsYXRlIHRoZSB3aW5kb3cncyBib3VuZHMKICAvLyB3aW5kb3cuKGlubmVyV2lkdGh8aW5uZXJIZWlnaHQpIGRvIG5vdCBhY2NvdW50IGZvciBzY3JvbGxiYXJzCiAgLy8gc28gcHJlZmVyIHRoZSBjbGllbnRXaWR0aC9jbGllbnRIZWlnaHQgb2YgdGhlIERPTSBpZiBhdmFpbGFibGUKCiAgdmFyIGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgd2luZG93LmlubmVyV2lkdGg7CiAgdmFyIGRvY3VtZW50SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCB8fCB3aW5kb3cuaW5uZXJIZWlnaHQ7CiAgdmFyIHdpbmRvd0JvdW5kaW5nQm94ID0gewogICAgdG9wOiAwLAogICAgcmlnaHQ6IGRvY3VtZW50V2lkdGgsCiAgICBib3R0b206IGRvY3VtZW50SGVpZ2h0LAogICAgbGVmdDogMCwKICAgIGhlaWdodDogZG9jdW1lbnRIZWlnaHQsCiAgICB3aWR0aDogZG9jdW1lbnRXaWR0aAogIH07IC8vIGlmIG5vIGNvbnRhaW5lciBlbGVtZW50IGlzIGdpdmVuIGZhbGwgYmFjayB0byB1c2luZyB0aGUgd2luZG93IHZpZXdwb3J0CgogIHZhciBjb250YWluZXJCb3VuZGluZ0JveCA9IGNvbnRhaW5lciA/IGdldEVsZW1lbnRCb3VuZGluZ0JveChjb250YWluZXIpIDogd2luZG93Qm91bmRpbmdCb3g7CiAgLyoqCiAgICogYHBvc2l0aW9uYCB3YXMgc3BlY2lmaWVkIGJ5IHRoZSBmdW5jdGlvbiBjYWxsZXIgYW5kIGlzIGEgc3Ryb25nIGhpbnQKICAgKiBhcyB0byB0aGUgcHJlZmVycmVkIGxvY2F0aW9uIG9mIHRoZSBwb3BvdmVyIHJlbGF0aXZlIHRvIHRoZSBhbmNob3IuCiAgICogSG93ZXZlciwgd2Ugc3Ryb25nbHkgcHJlZmVyIHNob3dpbmcgYWxsIG9mIHRoZSBwb3BvdmVyIGNvbnRlbnQgd2l0aGluCiAgICogdGhlIHdpbmRvdytjb250YWluZXIgYm91bmRhcnkgYW5kIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZSBmb3VyCiAgICogcG9zc2libGUgc2lkZXMgdW50aWwgYSBwZXJmZWN0IGZpdCBpcyBsb2NhdGVkLiBJZiBub25lIG9mIHRoZSBsb2NhdGlvbnMKICAgKiBmdWxseSBjb250YWluIHBvcG92ZXIsIHRoZSBsb2NhdGlvbiB3aXRoIHRoZSBiZXN0IGZpdCBpcyBzZWxlY3RlZC4KICAgKgogICAqIFRoaXMgYXBwcm9hY2ggZmlyc3QgY2hlY2tzIHRoZSBwcmVmZXJyZWQgYHBvc2l0aW9uYCwgdGhlbiBpdHMgb3Bwb3NpdGUKICAgKiBhbG9uZyB0aGUgc2FtZSBheGlzLCBuZXh0IGEgbG9jYXRpb24gb24gdGhlIGNyb3NzLWF4aXMsIGFuZCBmaW5hbGx5IGl0CiAgICogdGVzdHMgdGhlIHJlbWFpbmluZyBwb3NpdGlvbi4KICAgKgogICAqIGUuZy4KICAgKiBpZiBwb3NpdGlvbiA9ICJ0b3AiIHRoZSBvcmRlciBpcyB0b3AsIGJvdHRvbSwgbGVmdCByaWdodAogICAqIGlmIHBvc2l0aW9uID0gInJpZ2h0IiB0aGUgb3JkZXIgaXMgcmlnaHQsIGxlZnQsIHRvcCwgYm90dG9tCiAgICovCiAgLy8gVHJ5IHRoZSB1c2VyLWRlc2lyZWQgcG9zaXRpb24gZmlyc3QuCgogIHZhciBpdGVyYXRpb25Qb3NpdGlvbnMgPSBbcG9zaXRpb25dOyAvLyBrZWVwIHVzZXItZGVmaW5lZCBhbGlnbm1lbnQgaW4gdGhlIG9yaWdpbmFsIHBvc2l0aW9ucy4KCiAgdmFyIGl0ZXJhdGlvbkFsaWdubWVudHMgPSBbYWxpZ25dOwoKICBpZiAoZm9yY2VQb3NpdGlvbiAhPT0gdHJ1ZSkgewogICAgaXRlcmF0aW9uUG9zaXRpb25zLnB1c2gocG9zaXRpb25Db21wbGVtZW50c1twb3NpdGlvbl0pOyAvLyBUcnkgdGhlIGNvbXBsZW1lbnRhcnkgcG9zaXRpb24uCgogICAgaXRlcmF0aW9uQWxpZ25tZW50cy5wdXNoKGFsaWduKTsgLy8ga2VlcCB1c2VyLWRlZmluZWQgYWxpZ25tZW50IGluIHRoZSBjb21wbGVtZW50YXJ5IHBvc2l0aW9uLgoKICAgIGlmIChhbGxvd0Nyb3NzQXhpcykgewogICAgICBpdGVyYXRpb25Qb3NpdGlvbnMucHVzaChwb3NpdGlvblN1YnN0aXR1dGVzW3Bvc2l0aW9uXSwgLy8gU3dpdGNoIHRvIHRoZSBjcm9zcyBheGlzLgogICAgICBwb3NpdGlvbkNvbXBsZW1lbnRzW3Bvc2l0aW9uU3Vic3RpdHV0ZXNbcG9zaXRpb25dXSAvLyBUcnkgdGhlIGNvbXBsZW1lbnRhcnkgcG9zaXRpb24gb24gdGhlIGNyb3NzIGF4aXMuCiAgICAgICk7CiAgICAgIGl0ZXJhdGlvbkFsaWdubWVudHMucHVzaCh1bmRlZmluZWQsIHVuZGVmaW5lZCk7IC8vIGRpc2NhcmQgZGVzaXJlZCBhbGlnbm1lbnQgb24gY3Jvc3MtYXhpcwogICAgfQogIH0gZWxzZSB7CiAgICAvLyBwb3NpdGlvbiBpcyBmb3JjZWQsIGlmIGl0IGNvbmZsaWN0cyB3aXRoIHRoZSBhbGlnbm1lbnQgdGhlbiByZXNldCBhbGlnbiB0byBgbnVsbGAKICAgIC8vIGUuZy4gb3JpZ2luYWwgcGxhY2VtZW50IHJlcXVlc3QgZm9yIGBkb3duTGVmdGAgaXMgbW92ZWQgdG8gdGhlIGBsZWZ0YCBzaWRlLCBmdXR1cmUgY2FsbHMKICAgIC8vIHdpbGwgcG9zaXRpb24gYW5kIGFsaWduIGBsZWZ0YCwgYW5kIGBsZWZ0TGVmdGAgaXMgbm90IGEgdmFsaWQgcGxhY2VtZW50CiAgICBpZiAocG9zaXRpb24gPT09IGFsaWduIHx8IGFsaWduICE9PSB1bmRlZmluZWQgJiYgcG9zaXRpb24gPT09IHBvc2l0aW9uQ29tcGxlbWVudHNbYWxpZ25dKSB7CiAgICAgIGl0ZXJhdGlvbkFsaWdubWVudHNbMF0gPSB1bmRlZmluZWQ7CiAgICB9CiAgfQoKICB2YXIgYmVzdEZpdCA9IHVuZGVmaW5lZDsKICB2YXIgYmVzdFBvc2l0aW9uID0gbnVsbDsKCiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgaXRlcmF0aW9uUG9zaXRpb25zLmxlbmd0aDsgaWR4KyspIHsKICAgIHZhciBpdGVyYXRpb25Qb3NpdGlvbiA9IGl0ZXJhdGlvblBvc2l0aW9uc1tpZHhdOyAvLyBTZWUgaWYgd2UgY2FuIGZpbmQgYSBwb3NpdGlvbiB3aXRoIGEgYmV0dGVyIGZpdCB0aGFuIHdlJ3ZlIGZvdW5kIHNvIGZhci4KCiAgICB2YXIgc2NyZWVuQ29vcmRpbmF0ZXMgPSBnZXRQb3BvdmVyU2NyZWVuQ29vcmRpbmF0ZXMoewogICAgICBwb3NpdGlvbjogaXRlcmF0aW9uUG9zaXRpb24sCiAgICAgIGFsaWduOiBpdGVyYXRpb25BbGlnbm1lbnRzW2lkeF0sCiAgICAgIGFuY2hvckJvdW5kaW5nQm94OiBhbmNob3JCb3VuZGluZ0JveCwKICAgICAgcG9wb3ZlckJvdW5kaW5nQm94OiBwb3BvdmVyQm91bmRpbmdCb3gsCiAgICAgIHdpbmRvd0JvdW5kaW5nQm94OiB3aW5kb3dCb3VuZGluZ0JveCwKICAgICAgY29udGFpbmVyQm91bmRpbmdCb3g6IGNvbnRhaW5lckJvdW5kaW5nQm94LAogICAgICBvZmZzZXQ6IG9mZnNldCwKICAgICAgYnVmZmVyOiBidWZmZXIsCiAgICAgIGFycm93Q29uZmlnOiBhcnJvd0NvbmZpZwogICAgfSk7CgogICAgaWYgKGJlc3RGaXQgPT09IHVuZGVmaW5lZCB8fCBzY3JlZW5Db29yZGluYXRlcy5maXQgPiBiZXN0Rml0KSB7CiAgICAgIGJlc3RGaXQgPSBzY3JlZW5Db29yZGluYXRlcy5maXQ7CiAgICAgIGJlc3RQb3NpdGlvbiA9IHsKICAgICAgICBmaXQ6IHNjcmVlbkNvb3JkaW5hdGVzLmZpdCwKICAgICAgICBwb3NpdGlvbjogaXRlcmF0aW9uUG9zaXRpb24sCiAgICAgICAgdG9wOiBzY3JlZW5Db29yZGluYXRlcy50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsCiAgICAgICAgbGVmdDogc2NyZWVuQ29vcmRpbmF0ZXMubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCwKICAgICAgICBhcnJvdzogc2NyZWVuQ29vcmRpbmF0ZXMuYXJyb3cKICAgICAgfTsgLy8gSWYgd2UndmUgYWxyZWFkeSBmb3VuZCB0aGUgaWRlYWwgZml0LCB1c2UgdGhhdCBwb3NpdGlvbi4KCiAgICAgIGlmIChiZXN0Rml0ID09PSAxKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0gLy8gSWYgd2UgaGF2ZW4ndCBpbXByb3ZlZCB0aGUgZml0LCB0aGVuIGNvbnRpbnVlIG9uIGFuZCB0cnkgYSBuZXcgcG9zaXRpb24uCgogIH0KCiAgaWYgKGJlc3RQb3NpdGlvbiA9PSBudWxsKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjYWxjdWxhdGUgYmVzdFBvc2l0aW9uJyk7CiAgfQoKICBpZiAocmV0dXJuQm91bmRpbmdCb3gpIHsKICAgIGJlc3RQb3NpdGlvbi5hbmNob3JCb3VuZGluZ0JveCA9IGFuY2hvckJvdW5kaW5nQm94OwogIH0KCiAgcmV0dXJuIGJlc3RQb3NpdGlvbjsKfQoKLyoqCiAqIEdpdmVuIGEgdGFyZ2V0IHBvc2l0aW9uIGFuZCB0aGUgcG9wb3ZlcidzIHN1cnJvdW5kaW5nIGNvbnRleHQsIHJldHVybnMgZWl0aGVyIGFuCiAqIG9iamVjdCB3aXRoIHt0b3AsIGxlZnR9IHNjcmVlbiBjb29yZGluYXRlcyBvciBgbnVsbGAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gc2hvdwogKiBjb250ZW50IGluIHRoZSB0YXJnZXQgcG9zaXRpb24KICogQHBhcmFtIHBvc2l0aW9uIHtzdHJpbmd9IHRoZSB0YXJnZXQgcG9zaXRpb24sIG9uZSBvZiBbInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCJdCiAqIEBwYXJhbSBhbGlnbiB7c3RyaW5nfSB0YXJnZXQgYWxpZ25tZW50IG9uIHRoZSBjcm9zcy1heGlzLCBvbmUgb2YgWyJ0b3AiLCAicmlnaHQiLCAiYm90dG9tIiwgImxlZnQiXQogKiBAcGFyYW0gYW5jaG9yQm91bmRpbmdCb3gge09iamVjdH0gYm91bmRpbmcgYm94IG9mIHRoZSBhbmNob3IgZWxlbWVudAogKiBAcGFyYW0gcG9wb3ZlckJvdW5kaW5nQm94IHtPYmplY3R9IGJvdW5kaW5nIGJveCBvZiB0aGUgcG9wb3ZlciBlbGVtZW50CiAqIEBwYXJhbSB3aW5kb3dCb3VuZGluZ0JveCB7T2JqZWN0fSBib3VuZGluZyBib3ggb2YgdGhlIHdpbmRvdwogKiBAcGFyYW0gY29udGFpbmVyQm91bmRpbmdCb3gge09iamVjdH0gYm91bmRpbmcgYm94IG9mIHRoZSBjb250YWluZXIKICogQHBhcmFtIFthcnJvd0NvbmZpZ10ge3thcnJvd1dpZHRoOiBudW1iZXIsIGFycm93QnVmZmVyOiBudW1iZXJ9fSBJZiBwcmVzZW50LCBkZXNjcmliZXMgdGhlIHNpemUgJgogKiAgY29uc3RyYWludHMgZm9yIGFuIGFycm93IGVsZW1lbnQsIGFuZCB0aGUgZnVuY3Rpb24gcmV0dXJuIHZhbHVlIHdpbGwgaW5jbHVkZSBhbiBgYXJyb3dgIHBhcmFtCiAqICB3aXRoIHBvc2l0aW9uIGRldGFpbHMKICogQHBhcmFtIFtvZmZzZXQ9MF0ge251bWJlcn0gRGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9wb3ZlciBhbmQgdGhlIGFuY2hvcgogKiBAcGFyYW0gW2J1ZmZlcj0wXSB7bnVtYmVyfSBNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvcG92ZXIncwogKiAgcGxhY2VtZW50IGFuZCB0aGUgY29udGFpbmVyIGVkZ2UKICoKICogQHJldHVybnMge0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc1Jlc3VsdH0KICogIG9iamVjdCB3aXRoIHRvcC9sZWZ0IGNvb3JkaW5hdGVzLCB0aGUgcG9wb3ZlcidzIHJlbGF0aXZlIHBvc2l0aW9uIHRvIHRoZSBhbmNob3IsIGFuZCBob3cgd2VsbCB0aGUKICogIHBvcG92ZXIgZml0cyBpbiB0aGUgbG9jYXRpb24gKDAuMCAtPiAxLjApIGNvb3JkaW5hdGVzIGFuZCB0aGUgcG9wb3ZlcidzIHJlbGF0aXZlIHBvc2l0aW9uLCBpZgogKiAgdGhlcmUgaXMgbm8gcm9vbSBpbiB0aGlzIHBsYWNlbWVudCB0aGVuIG51bGwKICovCmV4cG9ydCBmdW5jdGlvbiBnZXRQb3BvdmVyU2NyZWVuQ29vcmRpbmF0ZXMoX3JlZjIpIHsKICB2YXIgX3BvcG92ZXJQbGFjZW1lbnQsIF9yZWYzOwoKICB2YXIgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbiwKICAgICAgYWxpZ24gPSBfcmVmMi5hbGlnbiwKICAgICAgYW5jaG9yQm91bmRpbmdCb3ggPSBfcmVmMi5hbmNob3JCb3VuZGluZ0JveCwKICAgICAgcG9wb3ZlckJvdW5kaW5nQm94ID0gX3JlZjIucG9wb3ZlckJvdW5kaW5nQm94LAogICAgICB3aW5kb3dCb3VuZGluZ0JveCA9IF9yZWYyLndpbmRvd0JvdW5kaW5nQm94LAogICAgICBjb250YWluZXJCb3VuZGluZ0JveCA9IF9yZWYyLmNvbnRhaW5lckJvdW5kaW5nQm94LAogICAgICBhcnJvd0NvbmZpZyA9IF9yZWYyLmFycm93Q29uZmlnLAogICAgICBfcmVmMiRvZmZzZXQgPSBfcmVmMi5vZmZzZXQsCiAgICAgIG9mZnNldCA9IF9yZWYyJG9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJG9mZnNldCwKICAgICAgX3JlZjIkYnVmZmVyID0gX3JlZjIuYnVmZmVyLAogICAgICBidWZmZXIgPSBfcmVmMiRidWZmZXIgPT09IHZvaWQgMCA/IDAgOiBfcmVmMiRidWZmZXI7CgogIC8qKgogICAqIFRoZSBnb2FsIGlzIHRvIGZpbmQgdGhlIGJlc3Qgd2F5IHRvIGFsaWduIHRoZSBwb3BvdmVyIGNvbnRlbnQKICAgKiBvbiB0aGUgZ2l2ZW4gc2lkZSBvZiB0aGUgYW5jaG9yIGVsZW1lbnQuIFRoZSBwb3BvdmVyIHByZWZlcnMKICAgKiBjZW50ZXJpbmcgb24gdGhlIGFuY2hvciBidXQgY2FuIHNoaWZ0IGFsb25nIHRoZSBjcm9zcy1heGlzIGFzIG5lZWRlZC4KICAgKgogICAqIFdlIHJldHVybiB0aGUgdG9wL2xlZnQgY29vcmRpbmF0ZXMgdGhhdCBiZXN0IGZpdCB0aGUgcG9wb3ZlciBpbnNpZGUKICAgKiB0aGUgZ2l2ZW4gYm91bmRhcmllcywgYW5kIGFsc28gcmV0dXJuIHRoZSBgZml0YCB2YWx1ZSB3aGljaCBpbmRpY2F0ZXMKICAgKiB3aGF0IHBlcmNlbnRhZ2Ugb2YgdGhlIHBvcG92ZXIgaXMgd2l0aGluIHRoZSBib3VuZHMuCiAgICoKICAgKiBlLmcuIGZpbmRpbmcgYSBsb2NhdGlvbiB3aGVuIHBvc2l0aW9uPXRvcAogICAqIHRoZSBwcmVmZXJyZWQgbG9jYXRpb24gaXMgZGlyZWN0bHkgb3ZlciB0aGUgYW5jaG9yCiAgICoKICAgKiAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rCiAgICogICAgICAgIHwgICAgICAgcG9wb3ZlciAgICAgICAgfAogICAqICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsKICAgKiAgICAgICAgICAgICAgICAgICB2CiAgICogICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rCiAgICogICAgICAgICAgICB8ICAgIGFuY2hvciAgICB8CiAgICogICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rCiAgICoKICAgKiBidXQgaWYgYW5jaG9yIGRvZXNuJ3QgaGF2ZSBtdWNoIChvciBhbnkpIHJvb20gb24gaXRzIHJpZGUgc2lkZQogICAqIHRoZSBwb3BvdmVyIHdpbGwgc2hpZnQgdG8gdGhlIGxlZnQKICAgKgogICAqICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKwogICAqICAgIHwgICAgICAgcG9wb3ZlciAgICAgICAgfAogICAqICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tKwogICAqICAgICAgICAgICAgICAgICAgIHYKICAgKiAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLSsKICAgKiAgICAgICAgICAgIHwgICAgYW5jaG9yICAgIHwKICAgKiAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLSsKICAgKgogICAqLwogIHZhciBjcm9zc0F4aXNGaXJzdFNpZGUgPSBwb3NpdGlvblN1YnN0aXR1dGVzW3Bvc2l0aW9uXTsgLy8gInRvcCIgLT4gImxlZnQiCgogIHZhciBjcm9zc0F4aXNTZWNvbmRTaWRlID0gcG9zaXRpb25Db21wbGVtZW50c1tjcm9zc0F4aXNGaXJzdFNpZGVdOyAvLyAibGVmdCIgLT4gInJpZ2h0IgoKICB2YXIgY3Jvc3NBeGlzRGltZW5zaW9uID0gcmVsYXRlZERpbWVuc2lvbltjcm9zc0F4aXNGaXJzdFNpZGVdOyAvLyAibGVmdCIgLT4gIndpZHRoIgoKICB2YXIgX2dldEJ1ZmZlclZhbHVlcyA9IGdldEJ1ZmZlclZhbHVlcyhidWZmZXIpLAogICAgICBfZ2V0QnVmZmVyVmFsdWVzMiA9IF9zbGljZWRUb0FycmF5KF9nZXRCdWZmZXJWYWx1ZXMsIDQpLAogICAgICB0b3BCdWZmZXIgPSBfZ2V0QnVmZmVyVmFsdWVzMlswXSwKICAgICAgcmlnaHRCdWZmZXIgPSBfZ2V0QnVmZmVyVmFsdWVzMlsxXSwKICAgICAgYm90dG9tQnVmZmVyID0gX2dldEJ1ZmZlclZhbHVlczJbMl0sCiAgICAgIGxlZnRCdWZmZXIgPSBfZ2V0QnVmZmVyVmFsdWVzMlszXTsKCiAgdmFyIF9nZXRDcm9zc0F4aXNQb3NpdGlvbiA9IGdldENyb3NzQXhpc1Bvc2l0aW9uKHsKICAgIGNyb3NzQXhpc0ZpcnN0U2lkZTogY3Jvc3NBeGlzRmlyc3RTaWRlLAogICAgY3Jvc3NBeGlzU2Vjb25kU2lkZTogY3Jvc3NBeGlzU2Vjb25kU2lkZSwKICAgIGNyb3NzQXhpc0RpbWVuc2lvbjogY3Jvc3NBeGlzRGltZW5zaW9uLAogICAgcG9zaXRpb246IHBvc2l0aW9uLAogICAgYWxpZ246IGFsaWduLAogICAgYnVmZmVyOiBidWZmZXIsCiAgICBvZmZzZXQ6IG9mZnNldCwKICAgIHdpbmRvd0JvdW5kaW5nQm94OiB3aW5kb3dCb3VuZGluZ0JveCwKICAgIGNvbnRhaW5lckJvdW5kaW5nQm94OiBjb250YWluZXJCb3VuZGluZ0JveCwKICAgIHBvcG92ZXJCb3VuZGluZ0JveDogcG9wb3ZlckJvdW5kaW5nQm94LAogICAgYW5jaG9yQm91bmRpbmdCb3g6IGFuY2hvckJvdW5kaW5nQm94LAogICAgYXJyb3dDb25maWc6IGFycm93Q29uZmlnCiAgfSksCiAgICAgIGNyb3NzQXhpc1Bvc2l0aW9uID0gX2dldENyb3NzQXhpc1Bvc2l0aW9uLmNyb3NzQXhpc1Bvc2l0aW9uLAogICAgICBjcm9zc0F4aXNBcnJvd1Bvc2l0aW9uID0gX2dldENyb3NzQXhpc1Bvc2l0aW9uLmNyb3NzQXhpc0Fycm93UG9zaXRpb247CgogIHZhciBwcmltYXJ5QXhpc0RpbWVuc2lvbiA9IHJlbGF0ZWREaW1lbnNpb25bcG9zaXRpb25dOyAvLyAidG9wIiAtPiAiaGVpZ2h0IgoKICB2YXIgcHJpbWFyeUF4aXNQb3NpdGlvbk5hbWUgPSBkaW1lbnNpb25Qb3NpdGlvbkF0dHJpYnV0ZVtwcmltYXJ5QXhpc0RpbWVuc2lvbl07IC8vICJoZWlnaHQiIC0+ICJ0b3AiCgogIHZhciBfZ2V0UHJpbWFyeUF4aXNQb3NpdGkgPSBnZXRQcmltYXJ5QXhpc1Bvc2l0aW9uKHsKICAgIHBvc2l0aW9uOiBwb3NpdGlvbiwKICAgIG9mZnNldDogb2Zmc2V0LAogICAgcG9wb3ZlckJvdW5kaW5nQm94OiBwb3BvdmVyQm91bmRpbmdCb3gsCiAgICBhbmNob3JCb3VuZGluZ0JveDogYW5jaG9yQm91bmRpbmdCb3gsCiAgICBhcnJvd0NvbmZpZzogYXJyb3dDb25maWcKICB9KSwKICAgICAgcHJpbWFyeUF4aXNQb3NpdGlvbiA9IF9nZXRQcmltYXJ5QXhpc1Bvc2l0aS5wcmltYXJ5QXhpc1Bvc2l0aW9uLAogICAgICBwcmltYXJ5QXhpc0Fycm93UG9zaXRpb24gPSBfZ2V0UHJpbWFyeUF4aXNQb3NpdGkucHJpbWFyeUF4aXNBcnJvd1Bvc2l0aW9uOwoKICB2YXIgcG9wb3ZlclBsYWNlbWVudCA9IChfcG9wb3ZlclBsYWNlbWVudCA9IHt9LCBfZGVmaW5lUHJvcGVydHkoX3BvcG92ZXJQbGFjZW1lbnQsIGNyb3NzQXhpc0ZpcnN0U2lkZSwgY3Jvc3NBeGlzUG9zaXRpb24pLCBfZGVmaW5lUHJvcGVydHkoX3BvcG92ZXJQbGFjZW1lbnQsIHByaW1hcnlBeGlzUG9zaXRpb25OYW1lLCBwcmltYXJ5QXhpc1Bvc2l0aW9uKSwgX3BvcG92ZXJQbGFjZW1lbnQpOyAvLyBjYWxjdWxhdGUgdGhlIGZpdCBvZiB0aGUgcG9wb3ZlciBpbiB0aGlzIGxvY2F0aW9uCiAgLy8gZml0IGlzIGluIHJhbmdlIDAuMCAtPiAxLjAgYW5kIGlzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBwb3BvdmVyIHdoaWNoIGlzIHZpc2libGUgaW4gdGhpcyBsb2NhdGlvbgoKICB2YXIgY29tYmluZWRCb3VuZGluZ0JveCA9IGludGVyc2VjdEJvdW5kaW5nQm94ZXMod2luZG93Qm91bmRpbmdCb3gsIGNvbnRhaW5lckJvdW5kaW5nQm94KTsgLy8gc2hyaW5rIHRoZSB2aXNpYmxlIGJvdW5kaW5nIGJveCBieSBgYnVmZmVyYAogIC8vIHRvIGNvbXB1dGUgYSBmaXQgdmFsdWUKCiAgY29tYmluZWRCb3VuZGluZ0JveC50b3AgKz0gdG9wQnVmZmVyOwogIGNvbWJpbmVkQm91bmRpbmdCb3gucmlnaHQgLT0gcmlnaHRCdWZmZXI7CiAgY29tYmluZWRCb3VuZGluZ0JveC5ib3R0b20gLT0gYm90dG9tQnVmZmVyOwogIGNvbWJpbmVkQm91bmRpbmdCb3gubGVmdCArPSBsZWZ0QnVmZmVyOwogIHZhciBmaXQgPSBnZXRWaXNpYmxlRml0KHsKICAgIHRvcDogcG9wb3ZlclBsYWNlbWVudC50b3AsCiAgICByaWdodDogcG9wb3ZlclBsYWNlbWVudC5sZWZ0ICsgcG9wb3ZlckJvdW5kaW5nQm94LndpZHRoLAogICAgYm90dG9tOiBwb3BvdmVyUGxhY2VtZW50LnRvcCArIHBvcG92ZXJCb3VuZGluZ0JveC5oZWlnaHQsCiAgICBsZWZ0OiBwb3BvdmVyUGxhY2VtZW50LmxlZnQsCiAgICB3aWR0aDogcG9wb3ZlckJvdW5kaW5nQm94LndpZHRoLAogICAgaGVpZ2h0OiBwb3BvdmVyQm91bmRpbmdCb3guaGVpZ2h0CiAgfSwgY29tYmluZWRCb3VuZGluZ0JveCk7CiAgdmFyIGFycm93ID0gYXJyb3dDb25maWcgPyAoX3JlZjMgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9yZWYzLCBjcm9zc0F4aXNGaXJzdFNpZGUsIGNyb3NzQXhpc0Fycm93UG9zaXRpb24gLSBwb3BvdmVyUGxhY2VtZW50W2Nyb3NzQXhpc0ZpcnN0U2lkZV0pLCBfZGVmaW5lUHJvcGVydHkoX3JlZjMsIHByaW1hcnlBeGlzUG9zaXRpb25OYW1lLCBwcmltYXJ5QXhpc0Fycm93UG9zaXRpb24pLCBfcmVmMykgOiB1bmRlZmluZWQ7CiAgcmV0dXJuIHsKICAgIGZpdDogZml0LAogICAgdG9wOiBwb3BvdmVyUGxhY2VtZW50LnRvcCwKICAgIGxlZnQ6IHBvcG92ZXJQbGFjZW1lbnQubGVmdCwKICAgIGFycm93OiBhcnJvdyA/IHsKICAgICAgbGVmdDogYXJyb3cubGVmdCwKICAgICAgdG9wOiBhcnJvdy50b3AKICAgIH0gOiB1bmRlZmluZWQKICB9Owp9CgpmdW5jdGlvbiBnZXRDcm9zc0F4aXNQb3NpdGlvbihfcmVmNCkgewogIHZhciBjcm9zc0F4aXNGaXJzdFNpZGUgPSBfcmVmNC5jcm9zc0F4aXNGaXJzdFNpZGUsCiAgICAgIGNyb3NzQXhpc1NlY29uZFNpZGUgPSBfcmVmNC5jcm9zc0F4aXNTZWNvbmRTaWRlLAogICAgICBjcm9zc0F4aXNEaW1lbnNpb24gPSBfcmVmNC5jcm9zc0F4aXNEaW1lbnNpb24sCiAgICAgIHBvc2l0aW9uID0gX3JlZjQucG9zaXRpb24sCiAgICAgIGFsaWduID0gX3JlZjQuYWxpZ24sCiAgICAgIGJ1ZmZlciA9IF9yZWY0LmJ1ZmZlciwKICAgICAgb2Zmc2V0ID0gX3JlZjQub2Zmc2V0LAogICAgICB3aW5kb3dCb3VuZGluZ0JveCA9IF9yZWY0LndpbmRvd0JvdW5kaW5nQm94LAogICAgICBjb250YWluZXJCb3VuZGluZ0JveCA9IF9yZWY0LmNvbnRhaW5lckJvdW5kaW5nQm94LAogICAgICBwb3BvdmVyQm91bmRpbmdCb3ggPSBfcmVmNC5wb3BvdmVyQm91bmRpbmdCb3gsCiAgICAgIGFuY2hvckJvdW5kaW5nQm94ID0gX3JlZjQuYW5jaG9yQm91bmRpbmdCb3gsCiAgICAgIGFycm93Q29uZmlnID0gX3JlZjQuYXJyb3dDb25maWc7CiAgLy8gaG93IG11Y2ggb2YgdGhlIHBvcG92ZXIgb3ZlcmZsb3dzIHBhc3QgZWl0aGVyIHNpZGUgb2YgdGhlIGFuY2hvciBpZiBpdHMgY2VudGVyZWQKICB2YXIgcG9wb3ZlclNpemVPbkNyb3NzQXhpcyA9IHBvcG92ZXJCb3VuZGluZ0JveFtjcm9zc0F4aXNEaW1lbnNpb25dOwogIHZhciBhbmNob3JTaXplT25Dcm9zc0F4aXMgPSBhbmNob3JCb3VuZGluZ0JveFtjcm9zc0F4aXNEaW1lbnNpb25dOwogIHZhciBhbmNob3JIYWxmU2l6ZSA9IGFuY2hvclNpemVPbkNyb3NzQXhpcyAvIDI7IC8vIHRoZSBwb3BvdmVyJ3Mgb3JpZ2luYWwgcG9zaXRpb24gb24gdGhlIGNyb3NzLWF4aXMgaXMgZGV0ZXJtaW5lZCBieToKCiAgdmFyIGNyb3NzQXhpc1Bvc2l0aW9uT3JpZ2luYWwgPSBhbmNob3JCb3VuZGluZ0JveFtjcm9zc0F4aXNGaXJzdFNpZGVdICsgLy8gd2hlcmUgdGhlIGFuY2hvciBpcyBsb2NhdGVkCiAgYW5jaG9ySGFsZlNpemUgLSAvLyBwbHVzIGhhbGYgYW5jaG9yIGRpbWVuc2lvbgogIHBvcG92ZXJTaXplT25Dcm9zc0F4aXMgLyAyOyAvLyBsZXNzIGhhbGYgdGhlIHBvcG92ZXIgZGltZW5zaW9uCiAgLy8gVG8gZml0IHRoZSBjb250ZW50IHdpdGhpbiBib3RoIHRoZSB3aW5kb3cgYW5kIGNvbnRhaW5lciwKICAvLyBjb21wdXRlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gc3BhY2VzIGFsb25nIGVhY2ggZWRnZQoKICB2YXIgY29tYmluZWRCb3VuZGluZ0JveCA9IGludGVyc2VjdEJvdW5kaW5nQm94ZXMod2luZG93Qm91bmRpbmdCb3gsIGNvbnRhaW5lckJvdW5kaW5nQm94KTsKICB2YXIgYXZhaWxhYmxlU3BhY2UgPSBnZXRBdmFpbGFibGVTcGFjZShhbmNob3JCb3VuZGluZ0JveCwgY29tYmluZWRCb3VuZGluZ0JveCwgYnVmZmVyLCBvZmZzZXQsIHBvc2l0aW9uKTsKICB2YXIgbWluaW11bVNwYWNlID0gYXJyb3dDb25maWcgPyBhcnJvd0NvbmZpZy5hcnJvd0J1ZmZlciA6IDA7CiAgdmFyIGNvbnRlbnRPdmVyZmxvd1NpemUgPSAocG9wb3ZlclNpemVPbkNyb3NzQXhpcyAtIGFuY2hvclNpemVPbkNyb3NzQXhpcykgLyAyOwogIHZhciBhbGlnbkFtb3VudCA9IDA7CiAgdmFyIGFsaWduRGlyZWN0aW9uID0gMTsKICB2YXIgYW1vdW50T2ZTaGlmdE5lZWRlZCA9IDA7CiAgdmFyIHNoaWZ0RGlyZWN0aW9uID0gMTsKCiAgaWYgKGFsaWduICE9IG51bGwpIHsKICAgIC8vIG5vIGFsaWdubWVudCwgZmluZCBob3cgbXVjaCB0aGUgY29udGFpbmVyIGJvdW5kYXJ5IHJlcXVpcmVzIHRoZSBjb250ZW50IHRvIHNoaWZ0CiAgICBhbGlnbkRpcmVjdGlvbiA9IGFsaWduID09PSAndG9wJyB8fCBhbGlnbiA9PT0gJ2xlZnQnID8gMSA6IC0xOwogICAgYWxpZ25BbW91bnQgPSBjb250ZW50T3ZlcmZsb3dTaXplOwogICAgdmFyIGFsaWduZWRPdmVyZmxvd0Ftb3VudCA9IGNvbnRlbnRPdmVyZmxvd1NpemUgKyBhbGlnbkFtb3VudDsKICAgIHZhciBuZWVkc1NoaWZ0ID0gYWxpZ25lZE92ZXJmbG93QW1vdW50ID4gYXZhaWxhYmxlU3BhY2VbcG9zaXRpb25Db21wbGVtZW50c1thbGlnbl1dOwogICAgYW1vdW50T2ZTaGlmdE5lZWRlZCA9IG5lZWRzU2hpZnQgPyBhbGlnbmVkT3ZlcmZsb3dBbW91bnQgLSBhdmFpbGFibGVTcGFjZVtwb3NpdGlvbkNvbXBsZW1lbnRzW2FsaWduXV0gOiAwOwogICAgc2hpZnREaXJlY3Rpb24gPSAtMSAqIGFsaWduRGlyZWN0aW9uOwogIH0gZWxzZSB7CiAgICAvLyBzaGlmdGluZyB0aGUgcG9wb3ZlciB0byBvbmUgc2lkZSBtYXkgeWllbGQgYSBiZXR0ZXIgZml0CiAgICB2YXIgc3BhY2VBdmFpbGFibGVPbkZpcnN0U2lkZSA9IGF2YWlsYWJsZVNwYWNlW2Nyb3NzQXhpc0ZpcnN0U2lkZV07CiAgICB2YXIgc3BhY2VBdmFpbGFibGVPblNlY29uZFNpZGUgPSBhdmFpbGFibGVTcGFjZVtjcm9zc0F4aXNTZWNvbmRTaWRlXTsKICAgIHZhciBpc1NoaWZ0VG93YXJkRmlyc3RTaWRlID0gc3BhY2VBdmFpbGFibGVPbkZpcnN0U2lkZSA+IHNwYWNlQXZhaWxhYmxlT25TZWNvbmRTaWRlOwogICAgc2hpZnREaXJlY3Rpb24gPSBpc1NoaWZ0VG93YXJkRmlyc3RTaWRlID8gLTEgOiAxOyAvLyBkZXRlcm1pbmUgd2hpY2ggZGlyZWN0aW9uIGhhcyBtb3JlIHJvb20gYW5kIHRoZSBwb3BvdmVyIHNob3VsZCBzaGlmdCB0bwoKICAgIHZhciBsZWFzdEF2YWlsYWJsZVNwYWNlID0gTWF0aC5taW4oc3BhY2VBdmFpbGFibGVPbkZpcnN0U2lkZSwgc3BhY2VBdmFpbGFibGVPblNlY29uZFNpZGUpOwoKICAgIHZhciBfbmVlZHNTaGlmdCA9IGNvbnRlbnRPdmVyZmxvd1NpemUgPiBsZWFzdEF2YWlsYWJsZVNwYWNlOwoKICAgIGFtb3VudE9mU2hpZnROZWVkZWQgPSBfbmVlZHNTaGlmdCA/IGNvbnRlbnRPdmVyZmxvd1NpemUgLSBsZWFzdEF2YWlsYWJsZVNwYWNlIDogMDsKICB9IC8vIHNoaWZ0IG92ZXIgdGhlIHBvcG92ZXIgaWYgbmVjZXNzYXJ5CgoKICB2YXIgc2hpZnRBbW91bnQgPSBhbW91bnRPZlNoaWZ0TmVlZGVkICogc2hpZnREaXJlY3Rpb247CiAgdmFyIGNyb3NzQXhpc1Bvc2l0aW9uID0gY3Jvc3NBeGlzUG9zaXRpb25PcmlnaW5hbCArIHNoaWZ0QW1vdW50ICsgYWxpZ25BbW91bnQgKiBhbGlnbkRpcmVjdGlvbjsgLy8gaWYgYW4gYGFycm93Q29uZmlnYCBpcyBzcGVjaWZpZWQsIGZpbmQgd2hlcmUgdG8gcG9zaXRpb24gdGhlIGFycm93CgogIHZhciBjcm9zc0F4aXNBcnJvd1Bvc2l0aW9uOwoKICBpZiAoYXJyb3dDb25maWcpIHsKICAgIHZhciBhcnJvd1dpZHRoID0gYXJyb3dDb25maWcuYXJyb3dXaWR0aDsKICAgIGNyb3NzQXhpc0Fycm93UG9zaXRpb24gPSBhbmNob3JCb3VuZGluZ0JveFtjcm9zc0F4aXNGaXJzdFNpZGVdICsgYW5jaG9ySGFsZlNpemUgLSBhcnJvd1dpZHRoIC8gMjsgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgZW5vdWdoIGJ1ZmZlciBhcm91bmQgdGhlIGFycm93CiAgICAvLyBieSBjYWxjdWxhdGluZyBob3cgaG93IG11Y2ggdGhlIGFycm93IHdvdWxkIG5lZWQgdG8gbW92ZQogICAgLy8gYnV0IGluc3RlYWQgb2YgbW92aW5nIHRoZSBhcnJvdywgc2hpZnQgdGhlIHBvcG92ZXIgY29udGVudAoKICAgIGlmIChjcm9zc0F4aXNBcnJvd1Bvc2l0aW9uIDwgY3Jvc3NBeGlzUG9zaXRpb24gKyBtaW5pbXVtU3BhY2UpIHsKICAgICAgLy8gYXJyb3cgaXMgdG9vIGNsb3NlIHRvIHRoZSBtaW5pbXVtIHNpZGUKICAgICAgdmFyIGRpZmZlcmVuY2UgPSBjcm9zc0F4aXNQb3NpdGlvbiArIG1pbmltdW1TcGFjZSAtIGNyb3NzQXhpc0Fycm93UG9zaXRpb247CiAgICAgIGNyb3NzQXhpc1Bvc2l0aW9uIC09IGRpZmZlcmVuY2U7CiAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Fycm93UG9zaXRpb24gKyBtaW5pbXVtU3BhY2UgKyBhcnJvd1dpZHRoID4gY3Jvc3NBeGlzUG9zaXRpb24gKyBwb3BvdmVyU2l6ZU9uQ3Jvc3NBeGlzKSB7CiAgICAgIC8vIGFycm93IGlzIHRvbyBjbG9zZSB0byB0aGUgbWF4aW11bSBzaWRlCiAgICAgIHZhciBlZGdlID0gY3Jvc3NBeGlzUG9zaXRpb24gKyBwb3BvdmVyU2l6ZU9uQ3Jvc3NBeGlzOwoKICAgICAgdmFyIF9kaWZmZXJlbmNlID0gY3Jvc3NBeGlzQXJyb3dQb3NpdGlvbiAtIChlZGdlIC0gbWluaW11bVNwYWNlIC0gYXJyb3dXaWR0aCk7CgogICAgICBjcm9zc0F4aXNQb3NpdGlvbiArPSBfZGlmZmVyZW5jZTsKICAgIH0KICB9CgogIHJldHVybiB7CiAgICBjcm9zc0F4aXNQb3NpdGlvbjogY3Jvc3NBeGlzUG9zaXRpb24sCiAgICBjcm9zc0F4aXNBcnJvd1Bvc2l0aW9uOiBjcm9zc0F4aXNBcnJvd1Bvc2l0aW9uCiAgfTsKfQoKZnVuY3Rpb24gZ2V0UHJpbWFyeUF4aXNQb3NpdGlvbihfcmVmNSkgewogIHZhciBwb3NpdGlvbiA9IF9yZWY1LnBvc2l0aW9uLAogICAgICBvZmZzZXQgPSBfcmVmNS5vZmZzZXQsCiAgICAgIHBvcG92ZXJCb3VuZGluZ0JveCA9IF9yZWY1LnBvcG92ZXJCb3VuZGluZ0JveCwKICAgICAgYW5jaG9yQm91bmRpbmdCb3ggPSBfcmVmNS5hbmNob3JCb3VuZGluZ0JveCwKICAgICAgYXJyb3dDb25maWcgPSBfcmVmNS5hcnJvd0NvbmZpZzsKICAvLyBpZiBwb3NpdGlvbmluZyB0byB0aGUgdG9wIG9yIGxlZnQsIHRoZSB0YXJnZXQgcG9zaXRpb24gZGVjcmVhc2VzCiAgLy8gZnJvbSB0aGUgYW5jaG9yJ3MgdG9wIG9yIGxlZnQsIG90aGVyd2lzZSB0aGUgcG9zaXRpb24gYWRkcyB0byB0aGUgYW5jaG9yJ3MKICB2YXIgaXNPZmZzZXREZWNyZWFzaW5nID0gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnbGVmdCc7CiAgdmFyIHByaW1hcnlBeGlzRGltZW5zaW9uID0gcmVsYXRlZERpbWVuc2lvbltwb3NpdGlvbl07IC8vICJ0b3AiIC0+ICJoZWlnaHQiCgogIHZhciBwb3BvdmVyU2l6ZU9uUHJpbWFyeUF4aXMgPSBwb3BvdmVyQm91bmRpbmdCb3hbcHJpbWFyeUF4aXNEaW1lbnNpb25dOyAvLyBzdGFydCBhdCB0aGUgdG9wIG9yIGxlZnQgZWRnZSBvZiB0aGUgYW5jaG9yIGVsZW1lbnQKCiAgdmFyIHByaW1hcnlBeGlzUG9zaXRpb25OYW1lID0gZGltZW5zaW9uUG9zaXRpb25BdHRyaWJ1dGVbcHJpbWFyeUF4aXNEaW1lbnNpb25dOyAvLyAiaGVpZ2h0IiAtPiAidG9wIgoKICB2YXIgYW5jaG9yRWRnZU9yaWdpbiA9IGFuY2hvckJvdW5kaW5nQm94W3ByaW1hcnlBeGlzUG9zaXRpb25OYW1lXTsgLy8gZmluZCB0aGUgcG9wb3ZlciBwb3NpdGlvbiBvbiB0aGUgcHJpbWFyeSBheGlzCgogIHZhciBhbmNob3JTaXplT25QcmltYXJ5QXhpcyA9IGFuY2hvckJvdW5kaW5nQm94W3ByaW1hcnlBeGlzRGltZW5zaW9uXTsKICB2YXIgcHJpbWFyeUF4aXNPZmZzZXQgPSBpc09mZnNldERlY3JlYXNpbmcgPyBwb3BvdmVyU2l6ZU9uUHJpbWFyeUF4aXMgOiBhbmNob3JTaXplT25QcmltYXJ5QXhpczsKICB2YXIgY29udGVudE9mZnNldCA9IChvZmZzZXQgKyBwcmltYXJ5QXhpc09mZnNldCkgKiAoaXNPZmZzZXREZWNyZWFzaW5nID8gLTEgOiAxKTsKICB2YXIgcHJpbWFyeUF4aXNQb3NpdGlvbiA9IGFuY2hvckVkZ2VPcmlnaW4gKyBjb250ZW50T2Zmc2V0OwogIHZhciBwcmltYXJ5QXhpc0Fycm93UG9zaXRpb247CgogIGlmIChhcnJvd0NvbmZpZykgewogICAgcHJpbWFyeUF4aXNBcnJvd1Bvc2l0aW9uID0gaXNPZmZzZXREZWNyZWFzaW5nID8gcG9wb3ZlclNpemVPblByaW1hcnlBeGlzIDogMDsKICB9CgogIHJldHVybiB7CiAgICBwcmltYXJ5QXhpc1Bvc2l0aW9uOiBwcmltYXJ5QXhpc1Bvc2l0aW9uLAogICAgcHJpbWFyeUF4aXNBcnJvd1Bvc2l0aW9uOiBwcmltYXJ5QXhpc0Fycm93UG9zaXRpb24KICB9Owp9Ci8qKgogKiBGaW5kcyB0aGUgY2xpZW50IHBpeGVsIGNvb3JkaW5hdGUgb2YgZWFjaCBlZGdlIGZvciB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIGJveCwKICogYW5kIHRoZSBib3VuZGluZyBib3gncyB3aWR0aCAmIGhlaWdodAogKgogKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50CiAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyfX0KICovCgoKZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRCb3VuZGluZ0JveChlbGVtZW50KSB7CiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogIHJldHVybiB7CiAgICB0b3A6IHJlY3QudG9wLAogICAgcmlnaHQ6IHJlY3QucmlnaHQsCiAgICBib3R0b206IHJlY3QuYm90dG9tLAogICAgbGVmdDogcmVjdC5sZWZ0LAogICAgaGVpZ2h0OiByZWN0LmhlaWdodCwKICAgIHdpZHRoOiByZWN0LndpZHRoCiAgfTsKfQovKioKICogQ2FsY3VsYXRlcyB0aGUgYXZhaWxhYmxlIGNvbnRlbnQgc3BhY2UgYmV0d2VlbiBhbmNob3IgYW5kIGNvbnRhaW5lcgogKgogKiBAcGFyYW0ge09iamVjdH0gYW5jaG9yQm91bmRpbmdCb3ggQ2xpZW50IGJvdW5kaW5nIGJveCBvZiB0aGUgYW5jaG9yIGVsZW1lbnQKICogQHBhcmFtIHtPYmplY3R9IGNvbnRhaW5lckJvdW5kaW5nQm94IENsaWVudCBib3VuZGluZyBib3ggb2YgdGhlIGNvbnRhaW5lciBlbGVtZW50CiAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXIgTWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3BvdmVyIGFuZCB0aGUgYm91bmRpbmcgY29udGFpbmVyCiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9wb3ZlciBhbmQgdGhlIGFuY2hvcgogKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0U2lkZSBTaWRlIHRoZSBvZmZzZXQgbmVlZHMgdG8gYmUgYXBwbGllZCB0bywgb25lCiAqICBvZiBbInRvcCIsICJyaWdodCIsICJib3R0b20iLCAibGVmdCJdCiAqIEByZXR1cm5zIHt7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fQogKi8KCmV4cG9ydCBmdW5jdGlvbiBnZXRBdmFpbGFibGVTcGFjZShhbmNob3JCb3VuZGluZ0JveCwgY29udGFpbmVyQm91bmRpbmdCb3gsIGJ1ZmZlciwgb2Zmc2V0LCBvZmZzZXRTaWRlKSB7CiAgdmFyIF9nZXRCdWZmZXJWYWx1ZXMzID0gZ2V0QnVmZmVyVmFsdWVzKGJ1ZmZlciksCiAgICAgIF9nZXRCdWZmZXJWYWx1ZXM0ID0gX3NsaWNlZFRvQXJyYXkoX2dldEJ1ZmZlclZhbHVlczMsIDQpLAogICAgICB0b3BCdWZmZXIgPSBfZ2V0QnVmZmVyVmFsdWVzNFswXSwKICAgICAgcmlnaHRCdWZmZXIgPSBfZ2V0QnVmZmVyVmFsdWVzNFsxXSwKICAgICAgYm90dG9tQnVmZmVyID0gX2dldEJ1ZmZlclZhbHVlczRbMl0sCiAgICAgIGxlZnRCdWZmZXIgPSBfZ2V0QnVmZmVyVmFsdWVzNFszXTsKCiAgcmV0dXJuIHsKICAgIHRvcDogYW5jaG9yQm91bmRpbmdCb3gudG9wIC0gY29udGFpbmVyQm91bmRpbmdCb3gudG9wIC0gdG9wQnVmZmVyIC0gKG9mZnNldFNpZGUgPT09ICd0b3AnID8gb2Zmc2V0IDogMCksCiAgICByaWdodDogY29udGFpbmVyQm91bmRpbmdCb3gucmlnaHQgLSBhbmNob3JCb3VuZGluZ0JveC5yaWdodCAtIHJpZ2h0QnVmZmVyIC0gKG9mZnNldFNpZGUgPT09ICdyaWdodCcgPyBvZmZzZXQgOiAwKSwKICAgIGJvdHRvbTogY29udGFpbmVyQm91bmRpbmdCb3guYm90dG9tIC0gYW5jaG9yQm91bmRpbmdCb3guYm90dG9tIC0gYm90dG9tQnVmZmVyIC0gKG9mZnNldFNpZGUgPT09ICdib3R0b20nID8gb2Zmc2V0IDogMCksCiAgICBsZWZ0OiBhbmNob3JCb3VuZGluZ0JveC5sZWZ0IC0gY29udGFpbmVyQm91bmRpbmdCb3gubGVmdCAtIGxlZnRCdWZmZXIgLSAob2Zmc2V0U2lkZSA9PT0gJ2xlZnQnID8gb2Zmc2V0IDogMCkKICB9Owp9Ci8qKgogKiBDb21wdXRlcyB0aGUgZml0IChvdmVybGFwKSBvZiB0aGUgY29udGVudCB3aXRoaW4gdGhlIGNvbnRhaW5lciwgZml0IGlzIGluIHJhbmdlIDAuMCA9PiAxLjAKICogQHBhcmFtIGNvbnRlbnRCb3VuZGluZ0JveCBib3VuZGluZyBib3ggb2YgY29udGVudCB0byBjYWxjdWxhdGUgZml0IGZvcgogKiBAcGFyYW0gY29udGFpbmVyQm91bmRpbmdCb3ggYm91bmRpbmcgYm94IG9mIGNvbnRhaW5lcgogKiBAcmV0dXJucyB7bnVtYmVyfQogKi8KCmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpYmxlRml0KGNvbnRlbnRCb3VuZGluZ0JveCwgY29udGFpbmVyQm91bmRpbmdCb3gpIHsKICB2YXIgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0Qm91bmRpbmdCb3hlcyhjb250ZW50Qm91bmRpbmdCb3gsIGNvbnRhaW5lckJvdW5kaW5nQm94KTsKCiAgaWYgKGludGVyc2VjdGlvbi5sZWZ0ID4gaW50ZXJzZWN0aW9uLnJpZ2h0IHx8IGludGVyc2VjdGlvbi50b3AgPiBpbnRlcnNlY3Rpb24udG9wKSB7CiAgICAvLyB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24sIHRoZSBib3hlcyBhcmUgY29tcGxldGVseSBzZXBhcmF0ZWQgb24gYXQgbGVhc3Qgb25lIGF4aXMKICAgIHJldHVybiAwOwogIH0KCiAgdmFyIGludGVyc2VjdGlvbkFyZWEgPSAoaW50ZXJzZWN0aW9uLnJpZ2h0IC0gaW50ZXJzZWN0aW9uLmxlZnQpICogKGludGVyc2VjdGlvbi5ib3R0b20gLSBpbnRlcnNlY3Rpb24udG9wKTsKICB2YXIgY29udGVudEFyZWEgPSAoY29udGVudEJvdW5kaW5nQm94LnJpZ2h0IC0gY29udGVudEJvdW5kaW5nQm94LmxlZnQpICogKGNvbnRlbnRCb3VuZGluZ0JveC5ib3R0b20gLSBjb250ZW50Qm91bmRpbmdCb3gudG9wKTsKICByZXR1cm4gaW50ZXJzZWN0aW9uQXJlYSAvIGNvbnRlbnRBcmVhOwp9Ci8qKgogKiBDYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gc3BhY2UgYmV0d2VlbiB0d28gYm91bmRpbmcgYm94ZXMKICoKICogQHBhcmFtIGZpcnN0Qm94CiAqIEBwYXJhbSBzZWNvbmRCb3gKICogQHJldHVybnMge0V1aUNsaWVudFJlY3R9CiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdEJvdW5kaW5nQm94ZXMoZmlyc3RCb3gsIHNlY29uZEJveCkgewogIHZhciB0b3AgPSBNYXRoLm1heChmaXJzdEJveC50b3AsIHNlY29uZEJveC50b3ApOwogIHZhciByaWdodCA9IE1hdGgubWluKGZpcnN0Qm94LnJpZ2h0LCBzZWNvbmRCb3gucmlnaHQpOwogIHZhciBib3R0b20gPSBNYXRoLm1pbihmaXJzdEJveC5ib3R0b20sIHNlY29uZEJveC5ib3R0b20pOwogIHZhciBsZWZ0ID0gTWF0aC5tYXgoZmlyc3RCb3gubGVmdCwgc2Vjb25kQm94LmxlZnQpOwogIHZhciBoZWlnaHQgPSBNYXRoLm1heChib3R0b20gLSB0b3AsIDApOwogIHZhciB3aWR0aCA9IE1hdGgubWF4KHJpZ2h0IC0gbGVmdCwgMCk7CiAgcmV0dXJuIHsKICAgIHRvcDogdG9wLAogICAgcmlnaHQ6IHJpZ2h0LAogICAgYm90dG9tOiBib3R0b20sCiAgICBsZWZ0OiBsZWZ0LAogICAgaGVpZ2h0OiBoZWlnaHQsCiAgICB3aWR0aDogd2lkdGgKICB9Owp9Ci8qKgogKiBSZXR1cm5zIHRoZSB0b3AtbW9zdCBkZWZpbmVkIHotaW5kZXggaW4gdGhlIGVsZW1lbnQncyBhbmNlc3RvciBoaWVyYXJjaHkKICogcmVsYXRpdmUgdG8gdGhlIGB0YXJnZXRgIGVsZW1lbnQ7IGlmIG5vIHotaW5kZXggaXMgZGVmaW5lZCwgcmV0dXJucyAwCiAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH0KICogQHBhcmFtIGNvdXNpbiB7SFRNTEVsZW1lbnR9CiAqIEByZXR1cm5zIHtudW1iZXJ9CiAqLwoKZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRaSW5kZXgoZWxlbWVudCwgY291c2luKSB7CiAgLyoqCiAgICogZmluZGluZyB0aGUgei1pbmRleCBvZiBgZWxlbWVudGAgaXMgbm90IHRoZSBmdWxsIHN0b3J5CiAgICogaXRzIHRoZSBDU1Mgc3RhY2tpbmcgY29udGV4dCB0aGF0IGlzIGltcG9ydGFudAogICAqIHRha2UgdGhpcyBET00gZm9yIGV4YW1wbGU6CiAgICogYm9keQogICAqICAgc2VjdGlvblt6LWluZGV4OiAxMDAwXQogICAqICAgICBwW3otaW5kZXg6IDUwMF0KICAgKiAgICAgICBidXR0b24KICAgKiAgIGRpdgogICAqCiAgICogd2hhdCB6LWluZGV4IGRvZXMgdGhlIGBkaXZgIG5lZWQgdG8gZGlzcGxheSBuZXh0IHRvIGBidXR0b25gPwogICAqIHRoZSBgZGl2YCBhbmQgYHNlY3Rpb25gIGFyZSB3aGVyZSB0aGUgc3RhY2tpbmcgY29udGV4dCBzcGxpdHMKICAgKiBzbyBgZGl2YCBuZWVkcyB0byBjb3B5IGBzZWN0aW9uYCdzIHotaW5kZXggaW4gb3JkZXIgdG8KICAgKiBhcHBlYXIgbmV4dCB0byAvIG92ZXIgYGJ1dHRvbmAKICAgKgogICAqIGNhbGN1bGF0ZSB0aGlzIGJ5IHN0YXJ0aW5nIGF0IGBidXR0b25gIGFuZCBmaW5kaW5nIGl0cyBvZmZzZXRQYXJlbnRzCiAgICogdGhlbiB3YWxrIHRoZSBwYXJlbnRzIGZyb20gdG9wIC0+IGRvd24gdW50aWwgdGhlIHN0YWNraW5nIGNvbnRleHQKICAgKiBzcGxpdCBpcyBmb3VuZCwgb3IgaWYgdGhlcmUgaXMgbm8gc3BsaXQgdGhlbiBhIHNwZWNpZmljIHotaW5kZXggaXMgdW5pbXBvcnRhbnQKICAgKi8KICAvLyBidWlsZCB0aGUgYXJyYXkgb2YgdGhlIGVsZW1lbnQgKyBpdHMgb2Zmc2V0IHBhcmVudHMKICB2YXIgbm9kZXNUb0luc3BlY3QgPSBbXTsKCiAgd2hpbGUgKHRydWUpIHsKICAgIG5vZGVzVG9JbnNwZWN0LnB1c2goZWxlbWVudCk7IC8vIEFGQUlDVCB0aGlzIGlzIGEgdmFsaWQgY2FzdCAtIHRoZSBsaWJkZWZzIGFwcGVhciB3cm9uZwoKICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDsgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBwYXJlbnQKCiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7CiAgICAgIGJyZWFrOwogICAgfSAvLyBzdG9wIGlmIHRoZSBwYXJlbnQgY29udGFpbnMgdGhlIHJlbGF0ZWQgZWxlbWVudAogICAgLy8gYXMgdGhpcyBpcyB0aGUgei1pbmRleCBhbmNlc3RvcgoKCiAgICBpZiAoZWxlbWVudC5jb250YWlucyhjb3VzaW4pKSB7CiAgICAgIGJyZWFrOwogICAgfQogIH0gLy8gcmV2ZXJzZSB0aGUgbm9kZXMgdG8gd2FsayBmcm9tIHRvcCAtPiBlbGVtZW50CgoKICBub2Rlc1RvSW5zcGVjdC5yZXZlcnNlKCk7CgogIGZvciAodmFyIF9pMiA9IDAsIF9ub2Rlc1RvSW5zcGVjdCA9IG5vZGVzVG9JbnNwZWN0OyBfaTIgPCBfbm9kZXNUb0luc3BlY3QubGVuZ3RoOyBfaTIrKykgewogICAgdmFyIG5vZGUgPSBfbm9kZXNUb0luc3BlY3RbX2kyXTsKICAgIC8vIGdldCB0aGlzIG5vZGUncyB6LWluZGV4IGNzcyB2YWx1ZQogICAgdmFyIHpJbmRleCA9IHdpbmRvdy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ3otaW5kZXgnKTsgLy8gaWYgdGhlIHotaW5kZXggaXMgbm90IGEgbnVtYmVyIChlLmcuICJhdXRvIikgcmV0dXJuIG51bGwsIGVsc2UgdGhlIHZhbHVlCgogICAgdmFyIHBhcnNlZFpJbmRleCA9IHBhcnNlSW50KHpJbmRleCwgMTApOwoKICAgIGlmICghaXNOYU4ocGFyc2VkWkluZGV4KSkgewogICAgICByZXR1cm4gcGFyc2VkWkluZGV4OwogICAgfQogIH0KCiAgcmV0dXJuIDA7Cn0KCnRyeSB7CiAgZmluZFBvcG92ZXJQb3NpdGlvbi5fX2RvY2dlbkluZm8gPSB7CiAgICBkZXNjcmlwdGlvbjogJ0NhbGN1bGF0ZXMgdGhlIGFic29sdXRlIHBvc2l0aW9uaW5nIChyZWxhdGl2ZSB0byBkb2N1bWVudC5ib2R5KSB0byBwbGFjZSBhIHBvcG92ZXIgZWxlbWVudCcsCiAgICBkaXNwbGF5TmFtZTogJ2ZpbmRQb3BvdmVyUG9zaXRpb24nLAogICAgbWV0aG9kczogW10sCiAgICBwcm9wczogewogICAgICBhbmNob3I6IHsKICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwsCiAgICAgICAgZGVzY3JpcHRpb246ICcnLAogICAgICAgIG5hbWU6ICdhbmNob3InLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnRmluZFBvcG92ZXJQb3NpdGlvbkFyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnSFRNTEVsZW1lbnQnCiAgICAgICAgfQogICAgICB9LAogICAgICBwb3BvdmVyOiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAncG9wb3ZlcicsCiAgICAgICAgcGFyZW50OiB7CiAgICAgICAgICBmaWxlTmFtZTogJ2V1aS9zcmMvc2VydmljZXMvcG9wb3Zlci9wb3BvdmVyX3Bvc2l0aW9uaW5nLnRzJywKICAgICAgICAgIG5hbWU6ICdGaW5kUG9wb3ZlclBvc2l0aW9uQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdIVE1MRWxlbWVudCcKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGFsaWduOiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAnYWxpZ24nLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnRmluZFBvcG92ZXJQb3NpdGlvbkFyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ2VudW0nLAogICAgICAgICAgcmF3OiAnRXVpUG9wb3ZlclBvc2l0aW9uJywKICAgICAgICAgIHZhbHVlOiBbewogICAgICAgICAgICB2YWx1ZTogJyJsZWZ0IicKICAgICAgICAgIH0sIHsKICAgICAgICAgICAgdmFsdWU6ICcicmlnaHQiJwogICAgICAgICAgfSwgewogICAgICAgICAgICB2YWx1ZTogJyJ0b3AiJwogICAgICAgICAgfSwgewogICAgICAgICAgICB2YWx1ZTogJyJib3R0b20iJwogICAgICAgICAgfV0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIHBvc2l0aW9uOiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAncG9zaXRpb24nLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnRmluZFBvcG92ZXJQb3NpdGlvbkFyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnZW51bScsCiAgICAgICAgICByYXc6ICdFdWlQb3BvdmVyUG9zaXRpb24nLAogICAgICAgICAgdmFsdWU6IFt7CiAgICAgICAgICAgIHZhbHVlOiAnImxlZnQiJwogICAgICAgICAgfSwgewogICAgICAgICAgICB2YWx1ZTogJyJyaWdodCInCiAgICAgICAgICB9LCB7CiAgICAgICAgICAgIHZhbHVlOiAnInRvcCInCiAgICAgICAgICB9LCB7CiAgICAgICAgICAgIHZhbHVlOiAnImJvdHRvbSInCiAgICAgICAgICB9XQogICAgICAgIH0KICAgICAgfSwKICAgICAgZm9yY2VQb3NpdGlvbjogewogICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ2ZvcmNlUG9zaXRpb24nLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnRmluZFBvcG92ZXJQb3NpdGlvbkFyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ2Jvb2xlYW4nCiAgICAgICAgfQogICAgICB9LAogICAgICBidWZmZXI6IHsKICAgICAgICBkZWZhdWx0VmFsdWU6IHsKICAgICAgICAgIHZhbHVlOiAnMTYnCiAgICAgICAgfSwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ2J1ZmZlcicsCiAgICAgICAgcGFyZW50OiB7CiAgICAgICAgICBmaWxlTmFtZTogJ2V1aS9zcmMvc2VydmljZXMvcG9wb3Zlci9wb3BvdmVyX3Bvc2l0aW9uaW5nLnRzJywKICAgICAgICAgIG5hbWU6ICdGaW5kUG9wb3ZlclBvc2l0aW9uQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnbnVtYmVyIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0nCiAgICAgICAgfQogICAgICB9LAogICAgICBvZmZzZXQ6IHsKICAgICAgICBkZWZhdWx0VmFsdWU6IHsKICAgICAgICAgIHZhbHVlOiAnMCcKICAgICAgICB9LAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAnb2Zmc2V0JywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL3NyYy9zZXJ2aWNlcy9wb3BvdmVyL3BvcG92ZXJfcG9zaXRpb25pbmcudHMnLAogICAgICAgICAgbmFtZTogJ0ZpbmRQb3BvdmVyUG9zaXRpb25BcmdzJwogICAgICAgIH0sCiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdudW1iZXInCiAgICAgICAgfQogICAgICB9LAogICAgICBhbGxvd0Nyb3NzQXhpczogewogICAgICAgIGRlZmF1bHRWYWx1ZTogewogICAgICAgICAgdmFsdWU6ICd0cnVlJwogICAgICAgIH0sCiAgICAgICAgZGVzY3JpcHRpb246ICcnLAogICAgICAgIG5hbWU6ICdhbGxvd0Nyb3NzQXhpcycsCiAgICAgICAgcGFyZW50OiB7CiAgICAgICAgICBmaWxlTmFtZTogJ2V1aS9zcmMvc2VydmljZXMvcG9wb3Zlci9wb3BvdmVyX3Bvc2l0aW9uaW5nLnRzJywKICAgICAgICAgIG5hbWU6ICdGaW5kUG9wb3ZlclBvc2l0aW9uQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnYm9vbGVhbicKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGNvbnRhaW5lcjogewogICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ2NvbnRhaW5lcicsCiAgICAgICAgcGFyZW50OiB7CiAgICAgICAgICBmaWxlTmFtZTogJ2V1aS9zcmMvc2VydmljZXMvcG9wb3Zlci9wb3BvdmVyX3Bvc2l0aW9uaW5nLnRzJywKICAgICAgICAgIG5hbWU6ICdGaW5kUG9wb3ZlclBvc2l0aW9uQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnSFRNTEVsZW1lbnQnCiAgICAgICAgfQogICAgICB9LAogICAgICBhcnJvd0NvbmZpZzogewogICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ2Fycm93Q29uZmlnJywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL3NyYy9zZXJ2aWNlcy9wb3BvdmVyL3BvcG92ZXJfcG9zaXRpb25pbmcudHMnLAogICAgICAgICAgbmFtZTogJ0ZpbmRQb3BvdmVyUG9zaXRpb25BcmdzJwogICAgICAgIH0sCiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICd7IGFycm93V2lkdGg6IG51bWJlcjsgYXJyb3dCdWZmZXI6IG51bWJlcjsgfScKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHJldHVybkJvdW5kaW5nQm94OiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAncmV0dXJuQm91bmRpbmdCb3gnLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnRmluZFBvcG92ZXJQb3NpdGlvbkFyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ2Jvb2xlYW4nCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgZXh0ZW5kZWRJbnRlcmZhY2VzOiBbJ0ZpbmRQb3BvdmVyUG9zaXRpb25BcmdzJywgJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnLCAnSFRNTEVsZW1lbnQnLCAnRWxlbWVudCcsICdOb2RlJywgJ0V2ZW50VGFyZ2V0JywgJ0FuaW1hdGFibGUnLCAnQ2hpbGROb2RlJywgJ0lubmVySFRNTCcsICdOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUnLCAnUGFyZW50Tm9kZScsICdEb2N1bWVudEFuZEVsZW1lbnRFdmVudEhhbmRsZXJzJywgJ0VsZW1lbnRDU1NJbmxpbmVTdHlsZScsICdFbGVtZW50Q29udGVudEVkaXRhYmxlJywgJ0dsb2JhbEV2ZW50SGFuZGxlcnMnLCAnSFRNTE9yU1ZHRWxlbWVudCddCiAgfTsKfSBjYXRjaCAoZSkge30KCnRyeSB7CiAgZ2V0UG9wb3ZlclNjcmVlbkNvb3JkaW5hdGVzLl9fZG9jZ2VuSW5mbyA9IHsKICAgIGRlc2NyaXB0aW9uOiAiR2l2ZW4gYSB0YXJnZXQgcG9zaXRpb24gYW5kIHRoZSBwb3BvdmVyJ3Mgc3Vycm91bmRpbmcgY29udGV4dCwgcmV0dXJucyBlaXRoZXIgYW5cbiIgKyAib2JqZWN0IHdpdGgge3RvcCwgbGVmdH0gc2NyZWVuIGNvb3JkaW5hdGVzIG9yIGBudWxsYCBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byBzaG93XG4iICsgJ2NvbnRlbnQgaW4gdGhlIHRhcmdldCBwb3NpdGlvbicsCiAgICBkaXNwbGF5TmFtZTogJ2dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlcycsCiAgICBtZXRob2RzOiBbXSwKICAgIHByb3BzOiB7CiAgICAgIHBvc2l0aW9uOiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAncG9zaXRpb24nLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnR2V0UG9wb3ZlclNjcmVlbkNvb3JkaW5hdGVzQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdlbnVtJywKICAgICAgICAgIHJhdzogJ0V1aVBvcG92ZXJQb3NpdGlvbicsCiAgICAgICAgICB2YWx1ZTogW3sKICAgICAgICAgICAgdmFsdWU6ICcibGVmdCInCiAgICAgICAgICB9LCB7CiAgICAgICAgICAgIHZhbHVlOiAnInJpZ2h0IicKICAgICAgICAgIH0sIHsKICAgICAgICAgICAgdmFsdWU6ICcidG9wIicKICAgICAgICAgIH0sIHsKICAgICAgICAgICAgdmFsdWU6ICciYm90dG9tIicKICAgICAgICAgIH1dCiAgICAgICAgfQogICAgICB9LAogICAgICBhbGlnbjogewogICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ2FsaWduJywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL3NyYy9zZXJ2aWNlcy9wb3BvdmVyL3BvcG92ZXJfcG9zaXRpb25pbmcudHMnLAogICAgICAgICAgbmFtZTogJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ2VudW0nLAogICAgICAgICAgcmF3OiAnRXVpUG9wb3ZlclBvc2l0aW9uJywKICAgICAgICAgIHZhbHVlOiBbewogICAgICAgICAgICB2YWx1ZTogJyJsZWZ0IicKICAgICAgICAgIH0sIHsKICAgICAgICAgICAgdmFsdWU6ICcicmlnaHQiJwogICAgICAgICAgfSwgewogICAgICAgICAgICB2YWx1ZTogJyJ0b3AiJwogICAgICAgICAgfSwgewogICAgICAgICAgICB2YWx1ZTogJyJib3R0b20iJwogICAgICAgICAgfV0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIGFuY2hvckJvdW5kaW5nQm94OiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAnYW5jaG9yQm91bmRpbmdCb3gnLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnR2V0UG9wb3ZlclNjcmVlbkNvb3JkaW5hdGVzQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdFdWlDbGllbnRSZWN0JwogICAgICAgIH0KICAgICAgfSwKICAgICAgcG9wb3ZlckJvdW5kaW5nQm94OiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAncG9wb3ZlckJvdW5kaW5nQm94JywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL3NyYy9zZXJ2aWNlcy9wb3BvdmVyL3BvcG92ZXJfcG9zaXRpb25pbmcudHMnLAogICAgICAgICAgbmFtZTogJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnRXVpQ2xpZW50UmVjdCcKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHdpbmRvd0JvdW5kaW5nQm94OiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAnd2luZG93Qm91bmRpbmdCb3gnLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvc3JjL3NlcnZpY2VzL3BvcG92ZXIvcG9wb3Zlcl9wb3NpdGlvbmluZy50cycsCiAgICAgICAgICBuYW1lOiAnR2V0UG9wb3ZlclNjcmVlbkNvb3JkaW5hdGVzQXJncycKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdFdWlDbGllbnRSZWN0JwogICAgICAgIH0KICAgICAgfSwKICAgICAgY29udGFpbmVyQm91bmRpbmdCb3g6IHsKICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwsCiAgICAgICAgZGVzY3JpcHRpb246ICcnLAogICAgICAgIG5hbWU6ICdjb250YWluZXJCb3VuZGluZ0JveCcsCiAgICAgICAgcGFyZW50OiB7CiAgICAgICAgICBmaWxlTmFtZTogJ2V1aS9zcmMvc2VydmljZXMvcG9wb3Zlci9wb3BvdmVyX3Bvc2l0aW9uaW5nLnRzJywKICAgICAgICAgIG5hbWU6ICdHZXRQb3BvdmVyU2NyZWVuQ29vcmRpbmF0ZXNBcmdzJwogICAgICAgIH0sCiAgICAgICAgcmVxdWlyZWQ6IHRydWUsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ0V1aUNsaWVudFJlY3QnCiAgICAgICAgfQogICAgICB9LAogICAgICBhcnJvd0NvbmZpZzogewogICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ2Fycm93Q29uZmlnJywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL3NyYy9zZXJ2aWNlcy9wb3BvdmVyL3BvcG92ZXJfcG9zaXRpb25pbmcudHMnLAogICAgICAgICAgbmFtZTogJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ3sgYXJyb3dXaWR0aDogbnVtYmVyOyBhcnJvd0J1ZmZlcjogbnVtYmVyOyB9JwogICAgICAgIH0KICAgICAgfSwKICAgICAgb2Zmc2V0OiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiB7CiAgICAgICAgICB2YWx1ZTogJzAnCiAgICAgICAgfSwKICAgICAgICBkZXNjcmlwdGlvbjogJycsCiAgICAgICAgbmFtZTogJ29mZnNldCcsCiAgICAgICAgcGFyZW50OiB7CiAgICAgICAgICBmaWxlTmFtZTogJ2V1aS9zcmMvc2VydmljZXMvcG9wb3Zlci9wb3BvdmVyX3Bvc2l0aW9uaW5nLnRzJywKICAgICAgICAgIG5hbWU6ICdHZXRQb3BvdmVyU2NyZWVuQ29vcmRpbmF0ZXNBcmdzJwogICAgICAgIH0sCiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdudW1iZXInCiAgICAgICAgfQogICAgICB9LAogICAgICBidWZmZXI6IHsKICAgICAgICBkZWZhdWx0VmFsdWU6IHsKICAgICAgICAgIHZhbHVlOiAnMCcKICAgICAgICB9LAogICAgICAgIGRlc2NyaXB0aW9uOiAnJywKICAgICAgICBuYW1lOiAnYnVmZmVyJywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL3NyYy9zZXJ2aWNlcy9wb3BvdmVyL3BvcG92ZXJfcG9zaXRpb25pbmcudHMnLAogICAgICAgICAgbmFtZTogJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogZmFsc2UsCiAgICAgICAgdHlwZTogewogICAgICAgICAgbmFtZTogJ251bWJlciB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdJwogICAgICAgIH0KICAgICAgfQogICAgfSwKICAgIGV4dGVuZGVkSW50ZXJmYWNlczogWydGaW5kUG9wb3ZlclBvc2l0aW9uQXJncycsICdHZXRQb3BvdmVyU2NyZWVuQ29vcmRpbmF0ZXNBcmdzJywgJ0hUTUxFbGVtZW50JywgJ0VsZW1lbnQnLCAnTm9kZScsICdFdmVudFRhcmdldCcsICdBbmltYXRhYmxlJywgJ0NoaWxkTm9kZScsICdJbm5lckhUTUwnLCAnTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlJywgJ1BhcmVudE5vZGUnLCAnRG9jdW1lbnRBbmRFbGVtZW50RXZlbnRIYW5kbGVycycsICdFbGVtZW50Q1NTSW5saW5lU3R5bGUnLCAnRWxlbWVudENvbnRlbnRFZGl0YWJsZScsICdHbG9iYWxFdmVudEhhbmRsZXJzJywgJ0hUTUxPclNWR0VsZW1lbnQnXQogIH07Cn0gY2F0Y2ggKGUpIHt9Cgp0cnkgewogIGdldEVsZW1lbnRCb3VuZGluZ0JveC5fX2RvY2dlbkluZm8gPSB7CiAgICBkZXNjcmlwdGlvbjogIkZpbmRzIHRoZSBjbGllbnQgcGl4ZWwgY29vcmRpbmF0ZSBvZiBlYWNoIGVkZ2UgZm9yIHRoZSBlbGVtZW50J3MgYm91bmRpbmcgYm94LFxuIiArICJhbmQgdGhlIGJvdW5kaW5nIGJveCdzIHdpZHRoICYgaGVpZ2h0IiwKICAgIGRpc3BsYXlOYW1lOiAnZ2V0RWxlbWVudEJvdW5kaW5nQm94JywKICAgIG1ldGhvZHM6IFtdLAogICAgcHJvcHM6IHsKICAgICAgY2xhc3NOYW1lOiB7CiAgICAgICAgZGVmYXVsdFZhbHVlOiBudWxsLAogICAgICAgIGRlc2NyaXB0aW9uOiAiUmV0dXJucyB0aGUgdmFsdWUgb2YgZWxlbWVudCdzIGNsYXNzIGNvbnRlbnQgYXR0cmlidXRlLiBDYW4gYmUgc2V0IHRvIGNoYW5nZSBpdC4iLAogICAgICAgIG5hbWU6ICdjbGFzc05hbWUnLAogICAgICAgIHBhcmVudDogewogICAgICAgICAgZmlsZU5hbWU6ICdldWkvbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQvbGliL2xpYi5kb20uZC50cycsCiAgICAgICAgICBuYW1lOiAnRWxlbWVudCcKICAgICAgICB9LAogICAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgICAgIHR5cGU6IHsKICAgICAgICAgIG5hbWU6ICdzdHJpbmcnCiAgICAgICAgfQogICAgICB9LAogICAgICBjaGlsZHJlbjogewogICAgICAgIGRlZmF1bHRWYWx1ZTogbnVsbCwKICAgICAgICBkZXNjcmlwdGlvbjogJ1JldHVybnMgdGhlIGNoaWxkIGVsZW1lbnRzLicsCiAgICAgICAgbmFtZTogJ2NoaWxkcmVuJywKICAgICAgICBwYXJlbnQ6IHsKICAgICAgICAgIGZpbGVOYW1lOiAnZXVpL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0L2xpYi9saWIuZG9tLmQudHMnLAogICAgICAgICAgbmFtZTogJ1BhcmVudE5vZGUnCiAgICAgICAgfSwKICAgICAgICByZXF1aXJlZDogdHJ1ZSwKICAgICAgICB0eXBlOiB7CiAgICAgICAgICBuYW1lOiAnSFRNTENvbGxlY3Rpb24nCiAgICAgICAgfQogICAgICB9CiAgICB9LAogICAgZXh0ZW5kZWRJbnRlcmZhY2VzOiBbJ0ZpbmRQb3BvdmVyUG9zaXRpb25BcmdzJywgJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnLCAnSFRNTEVsZW1lbnQnLCAnRWxlbWVudCcsICdOb2RlJywgJ0V2ZW50VGFyZ2V0JywgJ0FuaW1hdGFibGUnLCAnQ2hpbGROb2RlJywgJ0lubmVySFRNTCcsICdOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUnLCAnUGFyZW50Tm9kZScsICdEb2N1bWVudEFuZEVsZW1lbnRFdmVudEhhbmRsZXJzJywgJ0VsZW1lbnRDU1NJbmxpbmVTdHlsZScsICdFbGVtZW50Q29udGVudEVkaXRhYmxlJywgJ0dsb2JhbEV2ZW50SGFuZGxlcnMnLCAnSFRNTE9yU1ZHRWxlbWVudCddCiAgfTsKfSBjYXRjaCAoZSkge30KCnRyeSB7CiAgZ2V0QXZhaWxhYmxlU3BhY2UuX19kb2NnZW5JbmZvID0gewogICAgZGVzY3JpcHRpb246ICdDYWxjdWxhdGVzIHRoZSBhdmFpbGFibGUgY29udGVudCBzcGFjZSBiZXR3ZWVuIGFuY2hvciBhbmQgY29udGFpbmVyJywKICAgIGRpc3BsYXlOYW1lOiAnZ2V0QXZhaWxhYmxlU3BhY2UnLAogICAgbWV0aG9kczogW10sCiAgICBwcm9wczoge30sCiAgICBleHRlbmRlZEludGVyZmFjZXM6IFsnRmluZFBvcG92ZXJQb3NpdGlvbkFyZ3MnLCAnR2V0UG9wb3ZlclNjcmVlbkNvb3JkaW5hdGVzQXJncycsICdIVE1MRWxlbWVudCcsICdFbGVtZW50JywgJ05vZGUnLCAnRXZlbnRUYXJnZXQnLCAnQW5pbWF0YWJsZScsICdDaGlsZE5vZGUnLCAnSW5uZXJIVE1MJywgJ05vbkRvY3VtZW50VHlwZUNoaWxkTm9kZScsICdQYXJlbnROb2RlJywgJ0RvY3VtZW50QW5kRWxlbWVudEV2ZW50SGFuZGxlcnMnLCAnRWxlbWVudENTU0lubGluZVN0eWxlJywgJ0VsZW1lbnRDb250ZW50RWRpdGFibGUnLCAnR2xvYmFsRXZlbnRIYW5kbGVycycsICdIVE1MT3JTVkdFbGVtZW50J10KICB9Owp9IGNhdGNoIChlKSB7fQoKdHJ5IHsKICBnZXRWaXNpYmxlRml0Ll9fZG9jZ2VuSW5mbyA9IHsKICAgIGRlc2NyaXB0aW9uOiAnQ29tcHV0ZXMgdGhlIGZpdCAob3ZlcmxhcCkgb2YgdGhlIGNvbnRlbnQgd2l0aGluIHRoZSBjb250YWluZXIsIGZpdCBpcyBpbiByYW5nZSAwLjAgPT4gMS4wJywKICAgIGRpc3BsYXlOYW1lOiAnZ2V0VmlzaWJsZUZpdCcsCiAgICBtZXRob2RzOiBbXSwKICAgIHByb3BzOiB7fSwKICAgIGV4dGVuZGVkSW50ZXJmYWNlczogWydGaW5kUG9wb3ZlclBvc2l0aW9uQXJncycsICdHZXRQb3BvdmVyU2NyZWVuQ29vcmRpbmF0ZXNBcmdzJywgJ0hUTUxFbGVtZW50JywgJ0VsZW1lbnQnLCAnTm9kZScsICdFdmVudFRhcmdldCcsICdBbmltYXRhYmxlJywgJ0NoaWxkTm9kZScsICdJbm5lckhUTUwnLCAnTm9uRG9jdW1lbnRUeXBlQ2hpbGROb2RlJywgJ1BhcmVudE5vZGUnLCAnRG9jdW1lbnRBbmRFbGVtZW50RXZlbnRIYW5kbGVycycsICdFbGVtZW50Q1NTSW5saW5lU3R5bGUnLCAnRWxlbWVudENvbnRlbnRFZGl0YWJsZScsICdHbG9iYWxFdmVudEhhbmRsZXJzJywgJ0hUTUxPclNWR0VsZW1lbnQnXQogIH07Cn0gY2F0Y2ggKGUpIHt9Cgp0cnkgewogIGludGVyc2VjdEJvdW5kaW5nQm94ZXMuX19kb2NnZW5JbmZvID0gewogICAgZGVzY3JpcHRpb246ICdDYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gc3BhY2UgYmV0d2VlbiB0d28gYm91bmRpbmcgYm94ZXMnLAogICAgZGlzcGxheU5hbWU6ICdpbnRlcnNlY3RCb3VuZGluZ0JveGVzJywKICAgIG1ldGhvZHM6IFtdLAogICAgcHJvcHM6IHt9LAogICAgZXh0ZW5kZWRJbnRlcmZhY2VzOiBbJ0ZpbmRQb3BvdmVyUG9zaXRpb25BcmdzJywgJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnLCAnSFRNTEVsZW1lbnQnLCAnRWxlbWVudCcsICdOb2RlJywgJ0V2ZW50VGFyZ2V0JywgJ0FuaW1hdGFibGUnLCAnQ2hpbGROb2RlJywgJ0lubmVySFRNTCcsICdOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUnLCAnUGFyZW50Tm9kZScsICdEb2N1bWVudEFuZEVsZW1lbnRFdmVudEhhbmRsZXJzJywgJ0VsZW1lbnRDU1NJbmxpbmVTdHlsZScsICdFbGVtZW50Q29udGVudEVkaXRhYmxlJywgJ0dsb2JhbEV2ZW50SGFuZGxlcnMnLCAnSFRNTE9yU1ZHRWxlbWVudCddCiAgfTsKfSBjYXRjaCAoZSkge30KCnRyeSB7CiAgZ2V0RWxlbWVudFpJbmRleC5fX2RvY2dlbkluZm8gPSB7CiAgICBkZXNjcmlwdGlvbjogIlJldHVybnMgdGhlIHRvcC1tb3N0IGRlZmluZWQgei1pbmRleCBpbiB0aGUgZWxlbWVudCdzIGFuY2VzdG9yIGhpZXJhcmNoeVxuIiArICdyZWxhdGl2ZSB0byB0aGUgYHRhcmdldGAgZWxlbWVudDsgaWYgbm8gei1pbmRleCBpcyBkZWZpbmVkLCByZXR1cm5zIDAnLAogICAgZGlzcGxheU5hbWU6ICdnZXRFbGVtZW50WkluZGV4JywKICAgIG1ldGhvZHM6IFtdLAogICAgcHJvcHM6IHt9LAogICAgZXh0ZW5kZWRJbnRlcmZhY2VzOiBbJ0ZpbmRQb3BvdmVyUG9zaXRpb25BcmdzJywgJ0dldFBvcG92ZXJTY3JlZW5Db29yZGluYXRlc0FyZ3MnLCAnSFRNTEVsZW1lbnQnLCAnRWxlbWVudCcsICdOb2RlJywgJ0V2ZW50VGFyZ2V0JywgJ0FuaW1hdGFibGUnLCAnQ2hpbGROb2RlJywgJ0lubmVySFRNTCcsICdOb25Eb2N1bWVudFR5cGVDaGlsZE5vZGUnLCAnUGFyZW50Tm9kZScsICdEb2N1bWVudEFuZEVsZW1lbnRFdmVudEhhbmRsZXJzJywgJ0VsZW1lbnRDU1NJbmxpbmVTdHlsZScsICdFbGVtZW50Q29udGVudEVkaXRhYmxlJywgJ0dsb2JhbEV2ZW50SGFuZGxlcnMnLCAnSFRNTE9yU1ZHRWxlbWVudCddCiAgfTsKfSBjYXRjaCAoZSkge30="},{"version":3,"sources":["D:/work/eui/src/services/popover/popover_positioning.ts"],"names":["POSITIONS","relatedDimension","top","right","bottom","left","dimensionPositionAttribute","height","width","positionComplements","positionSubstitutes","getBufferValues","buffer","Array","isArray","topBuffer","rightBuffer","bottomBuffer","leftBuffer","findPopoverPosition","anchor","popover","align","position","forcePosition","offset","allowCrossAxis","container","arrowConfig","returnBoundingBox","anchorBoundingBox","getElementBoundingBox","popoverBoundingBox","documentWidth","document","documentElement","clientWidth","window","innerWidth","documentHeight","clientHeight","innerHeight","windowBoundingBox","containerBoundingBox","iterationPositions","iterationAlignments","push","undefined","bestFit","bestPosition","idx","length","iterationPosition","screenCoordinates","getPopoverScreenCoordinates","fit","pageYOffset","pageXOffset","arrow","Error","crossAxisFirstSide","crossAxisSecondSide","crossAxisDimension","getCrossAxisPosition","crossAxisPosition","crossAxisArrowPosition","primaryAxisDimension","primaryAxisPositionName","getPrimaryAxisPosition","primaryAxisPosition","primaryAxisArrowPosition","popoverPlacement","combinedBoundingBox","intersectBoundingBoxes","getVisibleFit","popoverSizeOnCrossAxis","anchorSizeOnCrossAxis","anchorHalfSize","crossAxisPositionOriginal","availableSpace","getAvailableSpace","minimumSpace","arrowBuffer","contentOverflowSize","alignAmount","alignDirection","amountOfShiftNeeded","shiftDirection","alignedOverflowAmount","needsShift","spaceAvailableOnFirstSide","spaceAvailableOnSecondSide","isShiftTowardFirstSide","leastAvailableSpace","Math","min","shiftAmount","arrowWidth","difference","edge","isOffsetDecreasing","popoverSizeOnPrimaryAxis","anchorEdgeOrigin","anchorSizeOnPrimaryAxis","primaryAxisOffset","contentOffset","element","rect","getBoundingClientRect","offsetSide","contentBoundingBox","intersection","intersectionArea","contentArea","firstBox","secondBox","max","getElementZIndex","cousin","nodesToInspect","offsetParent","contains","reverse","node","zIndex","defaultView","getComputedStyle","getPropertyValue","parsedZIndex","parseInt","isNaN"],"mappings":"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","sourcesContent":["/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { EuiPopoverPosition } from './types';\n\ntype Dimension = 'height' | 'width';\n\nexport const POSITIONS: EuiPopoverPosition[] = [\n  'top',\n  'right',\n  'bottom',\n  'left',\n];\n\ninterface BoundingBox {\n  [position: string]: number;\n  top: number;\n  right: number;\n  bottom: number;\n  left: number;\n}\n\nexport interface EuiClientRect extends BoundingBox {\n  height: number;\n  width: number;\n}\n\nconst relatedDimension: { [position in EuiPopoverPosition]: Dimension } = {\n  top: 'height',\n  right: 'width',\n  bottom: 'height',\n  left: 'width',\n};\n\nconst dimensionPositionAttribute: {\n  [dimension in Dimension]: 'top' | 'left';\n} = {\n  height: 'top',\n  width: 'left',\n};\n\nconst positionComplements: {\n  [position in EuiPopoverPosition]: EuiPopoverPosition;\n} = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\n// always resolving to top/left is taken advantage of by knowing they are the\n// minimum edges of the bounding box\nconst positionSubstitutes: {\n  [position in EuiPopoverPosition]: 'left' | 'top';\n} = {\n  top: 'left',\n  right: 'top',\n  bottom: 'left',\n  left: 'top',\n};\n\ninterface FindPopoverPositionArgs {\n  anchor: HTMLElement;\n  popover: HTMLElement;\n  align?: EuiPopoverPosition;\n  position: EuiPopoverPosition;\n  forcePosition?: boolean;\n  buffer?: number | [number, number, number, number];\n  offset?: number;\n  allowCrossAxis?: boolean;\n  container?: HTMLElement;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n  returnBoundingBox?: boolean;\n}\n\ninterface FindPopoverPositionResult {\n  top: number;\n  left: number;\n  position: 'top' | 'right' | 'bottom' | 'left';\n  fit: number;\n  arrow?: { left: number; top: number };\n  anchorBoundingBox?: EuiClientRect;\n}\n\nconst getBufferValues = (\n  buffer: number | [number, number, number, number]\n): [number, number, number, number] => {\n  if (Array.isArray(buffer)) {\n    const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = buffer;\n    return [topBuffer, rightBuffer, bottomBuffer, leftBuffer];\n  }\n  return [buffer, buffer, buffer, buffer];\n};\n\n/**\n * Calculates the absolute positioning (relative to document.body) to place a popover element\n *\n * @param anchor {HTMLElement} Element to anchor the popover to\n * @param popover {HTMLElement} Element containing the popover content\n * @param position {string} Position the user wants. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [forcePosition] {boolean} If true, use only the provided `position` value and don't try any other position\n * @param [align] {string} Cross-axis alignment. One of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param [buffer=16] {number} Minimum distance between the popover and the bounding container\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [allowCrossAxis=true] {boolean} Whether to allow the popover to be positioned on the cross-axis\n * @param [container] {HTMLElement} Element the popover must be constrained to fit within\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If\n *  present, describes the size & constraints for an arrow element, and the\n *  function return value will include an `arrow` param with position details\n *\n * @returns {FindPopoverPositionResult} absolute page coordinates for the\n * popover, and the placement's relation to the anchor or undefined\n * there's no room.\n */\nexport function findPopoverPosition({\n  anchor,\n  popover,\n  align,\n  position,\n  forcePosition,\n  buffer = 16,\n  offset = 0,\n  allowCrossAxis = true,\n  container,\n  arrowConfig,\n  returnBoundingBox,\n}: FindPopoverPositionArgs): FindPopoverPositionResult {\n  // find the screen-relative bounding boxes of the anchor, popover, and container\n  const anchorBoundingBox = getElementBoundingBox(anchor);\n  const popoverBoundingBox = getElementBoundingBox(popover);\n\n  // calculate the window's bounds\n  // window.(innerWidth|innerHeight) do not account for scrollbars\n  // so prefer the clientWidth/clientHeight of the DOM if available\n  const documentWidth =\n    document.documentElement.clientWidth || window.innerWidth;\n  const documentHeight =\n    document.documentElement.clientHeight || window.innerHeight;\n  const windowBoundingBox: EuiClientRect = {\n    top: 0,\n    right: documentWidth,\n    bottom: documentHeight,\n    left: 0,\n    height: documentHeight,\n    width: documentWidth,\n  };\n\n  // if no container element is given fall back to using the window viewport\n  const containerBoundingBox = container\n    ? getElementBoundingBox(container)\n    : windowBoundingBox;\n\n  /**\n   * `position` was specified by the function caller and is a strong hint\n   * as to the preferred location of the popover relative to the anchor.\n   * However, we strongly prefer showing all of the popover content within\n   * the window+container boundary and will iterate over the four\n   * possible sides until a perfect fit is located. If none of the locations\n   * fully contain popover, the location with the best fit is selected.\n   *\n   * This approach first checks the preferred `position`, then its opposite\n   * along the same axis, next a location on the cross-axis, and finally it\n   * tests the remaining position.\n   *\n   * e.g.\n   * if position = \"top\" the order is top, bottom, left right\n   * if position = \"right\" the order is right, left, top, bottom\n   */\n\n  // Try the user-desired position first.\n  const iterationPositions = [position];\n  // keep user-defined alignment in the original positions.\n  const iterationAlignments: Array<undefined | EuiPopoverPosition> = [align];\n\n  if (forcePosition !== true) {\n    iterationPositions.push(positionComplements[position]); // Try the complementary position.\n    iterationAlignments.push(align); // keep user-defined alignment in the complementary position.\n\n    if (allowCrossAxis) {\n      iterationPositions.push(\n        positionSubstitutes[position], // Switch to the cross axis.\n        positionComplements[positionSubstitutes[position]] // Try the complementary position on the cross axis.\n      );\n      iterationAlignments.push(undefined, undefined); // discard desired alignment on cross-axis\n    }\n  } else {\n    // position is forced, if it conflicts with the alignment then reset align to `null`\n    // e.g. original placement request for `downLeft` is moved to the `left` side, future calls\n    // will position and align `left`, and `leftLeft` is not a valid placement\n    if (\n      position === align ||\n      (align !== undefined && position === positionComplements[align])\n    ) {\n      iterationAlignments[0] = undefined;\n    }\n  }\n\n  let bestFit: number | undefined = undefined;\n  let bestPosition: FindPopoverPositionResult | null = null;\n\n  for (let idx = 0; idx < iterationPositions.length; idx++) {\n    const iterationPosition = iterationPositions[idx];\n\n    // See if we can find a position with a better fit than we've found so far.\n    const screenCoordinates = getPopoverScreenCoordinates({\n      position: iterationPosition,\n      align: iterationAlignments[idx],\n      anchorBoundingBox,\n      popoverBoundingBox,\n      windowBoundingBox,\n      containerBoundingBox,\n      offset,\n      buffer,\n      arrowConfig,\n    });\n\n    if (bestFit === undefined || screenCoordinates.fit > bestFit) {\n      bestFit = screenCoordinates.fit;\n      bestPosition = {\n        fit: screenCoordinates.fit,\n        position: iterationPosition,\n        top: screenCoordinates.top + window.pageYOffset,\n        left: screenCoordinates.left + window.pageXOffset,\n        arrow: screenCoordinates.arrow,\n      };\n\n      // If we've already found the ideal fit, use that position.\n      if (bestFit === 1) {\n        break;\n      }\n    }\n\n    // If we haven't improved the fit, then continue on and try a new position.\n  }\n\n  if (bestPosition == null) {\n    throw new Error('Failed to calculate bestPosition');\n  }\n\n  if (returnBoundingBox) {\n    bestPosition.anchorBoundingBox = anchorBoundingBox;\n  }\n\n  return bestPosition;\n}\n\ninterface GetPopoverScreenCoordinatesArgs {\n  position: EuiPopoverPosition;\n  align?: EuiPopoverPosition;\n  anchorBoundingBox: EuiClientRect;\n  popoverBoundingBox: EuiClientRect;\n  windowBoundingBox: EuiClientRect;\n  containerBoundingBox: EuiClientRect;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n  offset?: number;\n  buffer?: number | [number, number, number, number];\n}\n\ninterface GetPopoverScreenCoordinatesResult {\n  top: number;\n  left: number;\n  fit: number;\n  arrow: { top: number; left: number } | undefined;\n}\n\n/**\n * Given a target position and the popover's surrounding context, returns either an\n * object with {top, left} screen coordinates or `null` if it's not possible to show\n * content in the target position\n * @param position {string} the target position, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param align {string} target alignment on the cross-axis, one of [\"top\", \"right\", \"bottom\", \"left\"]\n * @param anchorBoundingBox {Object} bounding box of the anchor element\n * @param popoverBoundingBox {Object} bounding box of the popover element\n * @param windowBoundingBox {Object} bounding box of the window\n * @param containerBoundingBox {Object} bounding box of the container\n * @param [arrowConfig] {{arrowWidth: number, arrowBuffer: number}} If present, describes the size &\n *  constraints for an arrow element, and the function return value will include an `arrow` param\n *  with position details\n * @param [offset=0] {number} Distance between the popover and the anchor\n * @param [buffer=0] {number} Minimum distance between the popover's\n *  placement and the container edge\n *\n * @returns {GetPopoverScreenCoordinatesResult}\n *  object with top/left coordinates, the popover's relative position to the anchor, and how well the\n *  popover fits in the location (0.0 -> 1.0) coordinates and the popover's relative position, if\n *  there is no room in this placement then null\n */\nexport function getPopoverScreenCoordinates({\n  position,\n  align,\n  anchorBoundingBox,\n  popoverBoundingBox,\n  windowBoundingBox,\n  containerBoundingBox,\n  arrowConfig,\n  offset = 0,\n  buffer = 0,\n}: GetPopoverScreenCoordinatesArgs): GetPopoverScreenCoordinatesResult {\n  /**\n   * The goal is to find the best way to align the popover content\n   * on the given side of the anchor element. The popover prefers\n   * centering on the anchor but can shift along the cross-axis as needed.\n   *\n   * We return the top/left coordinates that best fit the popover inside\n   * the given boundaries, and also return the `fit` value which indicates\n   * what percentage of the popover is within the bounds.\n   *\n   * e.g. finding a location when position=top\n   * the preferred location is directly over the anchor\n   *\n   *        +----------------------+\n   *        |       popover        |\n   *        +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   * but if anchor doesn't have much (or any) room on its ride side\n   * the popover will shift to the left\n   *\n   *    +----------------------+\n   *    |       popover        |\n   *    +----------------------+\n   *                   v\n   *            +--------------+\n   *            |    anchor    |\n   *            +--------------+\n   *\n   */\n\n  const crossAxisFirstSide = positionSubstitutes[position]; // \"top\" -> \"left\"\n  const crossAxisSecondSide = positionComplements[crossAxisFirstSide]; // \"left\" -> \"right\"\n  const crossAxisDimension = relatedDimension[crossAxisFirstSide]; // \"left\" -> \"width\"\n\n  const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = getBufferValues(\n    buffer\n  );\n\n  const { crossAxisPosition, crossAxisArrowPosition } = getCrossAxisPosition({\n    crossAxisFirstSide,\n    crossAxisSecondSide,\n    crossAxisDimension,\n    position,\n    align,\n    buffer,\n    offset,\n    windowBoundingBox,\n    containerBoundingBox,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig,\n  });\n\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const primaryAxisPositionName =\n    dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n\n  const {\n    primaryAxisPosition,\n    primaryAxisArrowPosition,\n  } = getPrimaryAxisPosition({\n    position,\n    offset,\n    popoverBoundingBox,\n    anchorBoundingBox,\n    arrowConfig,\n  });\n\n  const popoverPlacement = {\n    [crossAxisFirstSide]: crossAxisPosition,\n    [primaryAxisPositionName]: primaryAxisPosition,\n  };\n\n  // calculate the fit of the popover in this location\n  // fit is in range 0.0 -> 1.0 and is the percentage of the popover which is visible in this location\n  const combinedBoundingBox = intersectBoundingBoxes(\n    windowBoundingBox,\n    containerBoundingBox\n  );\n\n  // shrink the visible bounding box by `buffer`\n  // to compute a fit value\n  combinedBoundingBox.top += topBuffer;\n  combinedBoundingBox.right -= rightBuffer;\n  combinedBoundingBox.bottom -= bottomBuffer;\n  combinedBoundingBox.left += leftBuffer;\n\n  const fit = getVisibleFit(\n    {\n      top: popoverPlacement.top,\n      right: popoverPlacement.left + popoverBoundingBox.width,\n      bottom: popoverPlacement.top + popoverBoundingBox.height,\n      left: popoverPlacement.left,\n      width: popoverBoundingBox.width,\n      height: popoverBoundingBox.height,\n    },\n    combinedBoundingBox\n  );\n\n  const arrow = arrowConfig\n    ? {\n        [crossAxisFirstSide]:\n          crossAxisArrowPosition! - popoverPlacement[crossAxisFirstSide],\n        [primaryAxisPositionName]: primaryAxisArrowPosition,\n      }\n    : undefined;\n\n  return {\n    fit,\n    top: popoverPlacement.top,\n    left: popoverPlacement.left,\n    arrow: arrow ? { left: arrow.left!, top: arrow.top! } : undefined,\n  };\n}\n\ninterface GetCrossAxisPositionArgs {\n  crossAxisFirstSide: EuiPopoverPosition;\n  crossAxisSecondSide: EuiPopoverPosition;\n  crossAxisDimension: Dimension;\n  position: EuiPopoverPosition;\n  align?: EuiPopoverPosition;\n  buffer: number | [number, number, number, number];\n  offset: number;\n  windowBoundingBox: EuiClientRect;\n  containerBoundingBox: EuiClientRect;\n  popoverBoundingBox: EuiClientRect;\n  anchorBoundingBox: EuiClientRect;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n}\n\ninterface CrossAxisPosition {\n  crossAxisPosition: number;\n  crossAxisArrowPosition: number | undefined;\n}\n\nfunction getCrossAxisPosition({\n  crossAxisFirstSide,\n  crossAxisSecondSide,\n  crossAxisDimension,\n  position,\n  align,\n  buffer,\n  offset,\n  windowBoundingBox,\n  containerBoundingBox,\n  popoverBoundingBox,\n  anchorBoundingBox,\n  arrowConfig,\n}: GetCrossAxisPositionArgs): CrossAxisPosition {\n  // how much of the popover overflows past either side of the anchor if its centered\n  const popoverSizeOnCrossAxis = popoverBoundingBox[crossAxisDimension];\n  const anchorSizeOnCrossAxis = anchorBoundingBox[crossAxisDimension];\n  const anchorHalfSize = anchorSizeOnCrossAxis / 2;\n\n  // the popover's original position on the cross-axis is determined by:\n  const crossAxisPositionOriginal =\n    anchorBoundingBox[crossAxisFirstSide] + // where the anchor is located\n    anchorHalfSize - // plus half anchor dimension\n    popoverSizeOnCrossAxis / 2; // less half the popover dimension\n\n  // To fit the content within both the window and container,\n  // compute the smaller of the two spaces along each edge\n  const combinedBoundingBox = intersectBoundingBoxes(\n    windowBoundingBox,\n    containerBoundingBox\n  );\n  const availableSpace = getAvailableSpace(\n    anchorBoundingBox,\n    combinedBoundingBox,\n    buffer,\n    offset,\n    position\n  );\n  const minimumSpace = arrowConfig ? arrowConfig.arrowBuffer : 0;\n\n  const contentOverflowSize =\n    (popoverSizeOnCrossAxis - anchorSizeOnCrossAxis) / 2;\n\n  let alignAmount = 0;\n  let alignDirection = 1;\n  let amountOfShiftNeeded = 0;\n  let shiftDirection = 1;\n\n  if (align != null) {\n    // no alignment, find how much the container boundary requires the content to shift\n    alignDirection = align === 'top' || align === 'left' ? 1 : -1;\n    alignAmount = contentOverflowSize;\n\n    const alignedOverflowAmount = contentOverflowSize + alignAmount;\n    const needsShift =\n      alignedOverflowAmount > availableSpace[positionComplements[align]];\n    amountOfShiftNeeded = needsShift\n      ? alignedOverflowAmount - availableSpace[positionComplements[align]]\n      : 0;\n    shiftDirection = -1 * alignDirection;\n  } else {\n    // shifting the popover to one side may yield a better fit\n    const spaceAvailableOnFirstSide = availableSpace[crossAxisFirstSide];\n    const spaceAvailableOnSecondSide = availableSpace[crossAxisSecondSide];\n\n    const isShiftTowardFirstSide =\n      spaceAvailableOnFirstSide > spaceAvailableOnSecondSide;\n    shiftDirection = isShiftTowardFirstSide ? -1 : 1;\n\n    // determine which direction has more room and the popover should shift to\n    const leastAvailableSpace = Math.min(\n      spaceAvailableOnFirstSide,\n      spaceAvailableOnSecondSide\n    );\n\n    const needsShift = contentOverflowSize > leastAvailableSpace;\n    amountOfShiftNeeded = needsShift\n      ? contentOverflowSize - leastAvailableSpace\n      : 0;\n  }\n\n  // shift over the popover if necessary\n  const shiftAmount = amountOfShiftNeeded * shiftDirection;\n  let crossAxisPosition =\n    crossAxisPositionOriginal + shiftAmount + alignAmount * alignDirection;\n\n  // if an `arrowConfig` is specified, find where to position the arrow\n  let crossAxisArrowPosition;\n  if (arrowConfig) {\n    const { arrowWidth } = arrowConfig;\n    crossAxisArrowPosition =\n      anchorBoundingBox[crossAxisFirstSide] + anchorHalfSize - arrowWidth / 2;\n\n    // make sure there's enough buffer around the arrow\n    // by calculating how how much the arrow would need to move\n    // but instead of moving the arrow, shift the popover content\n    if (crossAxisArrowPosition < crossAxisPosition + minimumSpace) {\n      // arrow is too close to the minimum side\n      const difference =\n        crossAxisPosition + minimumSpace - crossAxisArrowPosition;\n      crossAxisPosition -= difference;\n    } else if (\n      crossAxisArrowPosition + minimumSpace + arrowWidth >\n      crossAxisPosition + popoverSizeOnCrossAxis\n    ) {\n      // arrow is too close to the maximum side\n      const edge = crossAxisPosition + popoverSizeOnCrossAxis;\n      const difference =\n        crossAxisArrowPosition - (edge - minimumSpace - arrowWidth);\n      crossAxisPosition += difference;\n    }\n  }\n\n  return {\n    crossAxisPosition,\n    crossAxisArrowPosition,\n  };\n}\n\ninterface GetPrimaryAxisPositionArgs {\n  position: EuiPopoverPosition;\n  offset: number;\n  popoverBoundingBox: BoundingBox;\n  anchorBoundingBox: BoundingBox;\n  arrowConfig?: { arrowWidth: number; arrowBuffer: number };\n}\n\nfunction getPrimaryAxisPosition({\n  position,\n  offset,\n  popoverBoundingBox,\n  anchorBoundingBox,\n  arrowConfig,\n}: GetPrimaryAxisPositionArgs) {\n  // if positioning to the top or left, the target position decreases\n  // from the anchor's top or left, otherwise the position adds to the anchor's\n  const isOffsetDecreasing = position === 'top' || position === 'left';\n\n  const primaryAxisDimension = relatedDimension[position]; // \"top\" -> \"height\"\n  const popoverSizeOnPrimaryAxis = popoverBoundingBox[primaryAxisDimension];\n\n  // start at the top or left edge of the anchor element\n  const primaryAxisPositionName =\n    dimensionPositionAttribute[primaryAxisDimension]; // \"height\" -> \"top\"\n  const anchorEdgeOrigin = anchorBoundingBox[primaryAxisPositionName];\n\n  // find the popover position on the primary axis\n  const anchorSizeOnPrimaryAxis = anchorBoundingBox[primaryAxisDimension];\n  const primaryAxisOffset = isOffsetDecreasing\n    ? popoverSizeOnPrimaryAxis\n    : anchorSizeOnPrimaryAxis;\n  const contentOffset =\n    (offset + primaryAxisOffset!) * (isOffsetDecreasing ? -1 : 1);\n  const primaryAxisPosition = anchorEdgeOrigin + contentOffset;\n\n  let primaryAxisArrowPosition;\n\n  if (arrowConfig) {\n    primaryAxisArrowPosition = isOffsetDecreasing\n      ? popoverSizeOnPrimaryAxis\n      : 0;\n  }\n\n  return {\n    primaryAxisPosition,\n    primaryAxisArrowPosition,\n  };\n}\n\n/**\n * Finds the client pixel coordinate of each edge for the element's bounding box,\n * and the bounding box's width & height\n *\n * @param {HTMLElement} element\n * @returns {{top: number, right: number, bottom: number, left: number, height: number, width: number}}\n */\nexport function getElementBoundingBox(element: HTMLElement): EuiClientRect {\n  const rect = element.getBoundingClientRect();\n  return {\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    height: rect.height,\n    width: rect.width,\n  };\n}\n\n/**\n * Calculates the available content space between anchor and container\n *\n * @param {Object} anchorBoundingBox Client bounding box of the anchor element\n * @param {Object} containerBoundingBox Client bounding box of the container element\n * @param {number} buffer Minimum distance between the popover and the bounding container\n * @param {number} offset Distance between the popover and the anchor\n * @param {string} offsetSide Side the offset needs to be applied to, one\n *  of [\"top\", \"right\", \"bottom\", \"left\"]\n * @returns {{top: number, right: number, bottom: number, left: number}}\n */\nexport function getAvailableSpace(\n  anchorBoundingBox: BoundingBox,\n  containerBoundingBox: BoundingBox,\n  buffer: number | [number, number, number, number],\n  offset: number,\n  offsetSide: EuiPopoverPosition\n): BoundingBox {\n  const [topBuffer, rightBuffer, bottomBuffer, leftBuffer] = getBufferValues(\n    buffer\n  );\n  return {\n    top:\n      anchorBoundingBox.top -\n      containerBoundingBox.top -\n      topBuffer -\n      (offsetSide === 'top' ? offset : 0),\n    right:\n      containerBoundingBox.right -\n      anchorBoundingBox.right -\n      rightBuffer -\n      (offsetSide === 'right' ? offset : 0),\n    bottom:\n      containerBoundingBox.bottom -\n      anchorBoundingBox.bottom -\n      bottomBuffer -\n      (offsetSide === 'bottom' ? offset : 0),\n    left:\n      anchorBoundingBox.left -\n      containerBoundingBox.left -\n      leftBuffer -\n      (offsetSide === 'left' ? offset : 0),\n  };\n}\n\n/**\n * Computes the fit (overlap) of the content within the container, fit is in range 0.0 => 1.0\n * @param contentBoundingBox bounding box of content to calculate fit for\n * @param containerBoundingBox bounding box of container\n * @returns {number}\n */\nexport function getVisibleFit(\n  contentBoundingBox: BoundingBox,\n  containerBoundingBox: BoundingBox\n): number {\n  const intersection = intersectBoundingBoxes(\n    contentBoundingBox,\n    containerBoundingBox\n  );\n\n  if (\n    intersection.left > intersection.right ||\n    intersection.top > intersection.top\n  ) {\n    // there is no intersection, the boxes are completely separated on at least one axis\n    return 0;\n  }\n\n  const intersectionArea =\n    (intersection.right - intersection.left) *\n    (intersection.bottom - intersection.top);\n  const contentArea =\n    (contentBoundingBox.right - contentBoundingBox.left) *\n    (contentBoundingBox.bottom - contentBoundingBox.top);\n\n  return intersectionArea / contentArea;\n}\n\n/**\n * Calculates the intersection space between two bounding boxes\n *\n * @param firstBox\n * @param secondBox\n * @returns {EuiClientRect}\n */\nexport function intersectBoundingBoxes(\n  firstBox: BoundingBox,\n  secondBox: BoundingBox\n): EuiClientRect {\n  const top = Math.max(firstBox.top, secondBox.top);\n  const right = Math.min(firstBox.right, secondBox.right);\n  const bottom = Math.min(firstBox.bottom, secondBox.bottom);\n  const left = Math.max(firstBox.left, secondBox.left);\n  const height = Math.max(bottom - top, 0);\n  const width = Math.max(right - left, 0);\n\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    height,\n    width,\n  };\n}\n\n/**\n * Returns the top-most defined z-index in the element's ancestor hierarchy\n * relative to the `target` element; if no z-index is defined, returns 0\n * @param element {HTMLElement}\n * @param cousin {HTMLElement}\n * @returns {number}\n */\nexport function getElementZIndex(\n  element: HTMLElement,\n  cousin: HTMLElement\n): number {\n  /**\n   * finding the z-index of `element` is not the full story\n   * its the CSS stacking context that is important\n   * take this DOM for example:\n   * body\n   *   section[z-index: 1000]\n   *     p[z-index: 500]\n   *       button\n   *   div\n   *\n   * what z-index does the `div` need to display next to `button`?\n   * the `div` and `section` are where the stacking context splits\n   * so `div` needs to copy `section`'s z-index in order to\n   * appear next to / over `button`\n   *\n   * calculate this by starting at `button` and finding its offsetParents\n   * then walk the parents from top -> down until the stacking context\n   * split is found, or if there is no split then a specific z-index is unimportant\n   */\n\n  // build the array of the element + its offset parents\n  const nodesToInspect: HTMLElement[] = [];\n  while (true) {\n    nodesToInspect.push(element);\n\n    // AFAICT this is a valid cast - the libdefs appear wrong\n    element = element.offsetParent as HTMLElement;\n\n    // stop if there is no parent\n    if (element == null) {\n      break;\n    }\n\n    // stop if the parent contains the related element\n    // as this is the z-index ancestor\n    if (element.contains(cousin)) {\n      break;\n    }\n  }\n\n  // reverse the nodes to walk from top -> element\n  nodesToInspect.reverse();\n\n  for (const node of nodesToInspect) {\n    // get this node's z-index css value\n    const zIndex = window.document\n      .defaultView!.getComputedStyle(node)\n      .getPropertyValue('z-index');\n\n    // if the z-index is not a number (e.g. \"auto\") return null, else the value\n    const parsedZIndex = parseInt(zIndex, 10);\n    if (!isNaN(parsedZIndex)) {\n      return parsedZIndex;\n    }\n  }\n\n  return 0;\n}\n"]}]}